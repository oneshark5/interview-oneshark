# ES6

## 一、面经收集



## 二、面试官系列

### 问题1：说说var、let、const之间的区别

**1. var**

在ES5中，顶层对象的属性和全局变量是等价的，用`var`声明的变量既是全局变量，也是顶层变量；

注意：顶层对象，在浏览器环境指的是`window`对象，在 `Node` 指的是`global`对象；即在浏览器中采用`var`声明的变量为全局变量，是顶层window对象的属性。

```js
var a = 10;
console.log(window.a) // 10
```

- 使用`var`声明的变量存在==变量提升==的情况

- 使用`var`，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明

- 在函数作用域中采用`var`声明变量，变量不会超过该作用域，但是直接采用`a = 25`赋值，则该变量就变成全局变量。

  ```js
  var a = 20
  function change(){
      var a = 30
  }
  change()
  console.log(a) // 20 
  
  // 不适用var
  var a = 20
  function change(){
     a = 30
  }
  change()
  console.log(a) // 30 
  ```

**2. let**

- 所声明的变量，只在`let`命令所在的代码块内有效，==不存在变量提升==。

  ```js
  {
      let a = 20
  }
  console.log(a) // ReferenceError: a is not defined.
  // 若在未声明之前使用，则报错
  console.log(b) // 报错ReferenceError
  let b = 2
  ```

- 暂时性死区：使用`let`声明变量前，该变量都不可用；只要块级作用域内存在`let`命令，这个区域就不再受外部影响。

  ```js
  // 在块作用域中提前使用了a变量，但是存在let的地方不会，变量未声明就不可用，所以不会使用到全局作用域中的 a
  var a = 123
  if (true) {
      a = 'abc' // ReferenceError
      let a;
  }
  ```

- `let`不允许在==相同作用域中==重复声明。

  ```js
  // 相同作用域中出现同一声明才会报错，像这种不同作用域不会报错
  let a = 20
  {
      let a = 30
  }
  ```

**3. const**

`const`声明一个只读的常量，一旦声明，常量的值就不能改变。并且一旦采用`const`声明变量，就必须立即初始化。

```js
const a = 1
a = 3
// TypeError: Assignment to constant variable.
const b;
// SyntaxError: Missing initializer in const declaration
```

- 如果之前用`var`或`let`声明过变量，再用`const`声明同样会报错

- `const`实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动

- 对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的，并不能确保改变量的结构不变。🦈如果是复杂类型，`const`保存的指向数据的指针是不变的，而数据自己的结构是可以改变的。

  ```js
  const foo = {};
  
  // 为 foo 添加一个属性，可以成功
  foo.prop = 123;
  foo.prop // 123
  
  // 将 foo 指向另一个对象，就会报错
  foo = {}; // TypeError: "foo" is read-only
  ```

**4. 区别**

`var`、`let`、`const`三者区别可以围绕下面五点展开：

- 变量提升
- 暂时性死区
- 块级作用域
- 重复声明
- 修改声明的变量
- 使用

**变量提升**

`var`声明的变量存在变量提升，即变量可以在声明之前调用，值为`undefined`。

`let`和`const`不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错

**暂时性死区**

`var`不存在暂时性死区

`let`和`const`存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量

🦈采用`let`和`const`声明的变量，在声明之前不可用。

**块作用域**

`var`不存在块级作用域

`let`和`const`存在块级作用域

**重复声明**

`var`允许重复声明变量；重复声明后，后面的会替代前面已有的声明。

`let`和`const`在同一作用域不允许重复声明变量。

**修改声明的变量**

`var`和`let`可以

`const`声明一个只读的常量。一旦声明，常量的值就不能改变

**使用**

能用`const`的情况尽量使用`const`，其他情况下大多数使用`let`，避免使用`var`

### 问题2：数组新增了哪些扩展？

**1. 扩展运算符**

`...`将数组转为参数序列。

- 主要用于函数调用的时候，将一个数组变为参数序列；🦈把数组中的元素取出（转成参数序列）作为参数传给函数。

- 复制数组

  扩展运算符会克隆一个全新的数组，对于新旧数组更改自己的元素，不会影响到另外一个数组。

  🦈所以采用扩展运算符复制数组时，是在栈内存中开辟了一个新的空间，形成了一个新的数组。新旧数组互补干扰

  ```js
  const a1 = [1, 2];
  // 写法一
  const a2 = [...a1];
  // 写法二
  const [...a2] = a1;
  
  // 复制后，更改属任一数组，都不会影响到另外一个数组
  a1[0] = 5
  console.log(a1) // [5, 2]
  console.log(a2) // [1, 2]
  ```

- 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错

  ```js
  const [first, ...rest] = [1, 2, 3, 4, 5];
  first // 1
  rest  // [2, 3, 4, 5]
  
  // 在用扩展运算符赋值时，用在非最后一位则会报错
  const [...butLast, last] = [1, 2, 3, 4, 5];
  // 报错
  
  const [first, ...middle, last] = [1, 2, 3, 4, 5];
  // 报错
  ```

- 可以将字符串转为真正的数组

  ```javascript
  [...'hello']
  // [ "h", "e", "l", "l", "o" ]
  ```



**2. 构造函数新增方法**

- `Array.from()`

  将两类对象转为真正的数组：类似数组的对象和可遍历`（iterable）`的对象（包括 `ES6` 新增的数据结构 `Set` 和 `Map`）

  ```js
  let arrayLike = {
      '0': 'a',
      '1': 'b',
      '2': 'c',
      length: 3
  };
  let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
  ```

  还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组

  ```js
  Array.from([1, 2, 3], (x) => x * x)
  // [1, 4, 9]
  ```

- `Array.of()`

  🦈将参数序列转为数组

  用于将一组值，转换为数组

  ```js
  Array.of(3, 11, 8) // [3,11,8]
  ```

  没有参数的时候，返回一个空数组

  当参数只有一个的时候，实际上是指定数组的长度

  参数个数不少于 2 个时，`Array()`才会返回由参数组成的新数组

  ```js
  Array() // []
  Array(3) // [, , ,]
  Array(3, 11, 8) // [3, 11, 8]
  ```

**3. 实例对象新增方法**

关于数组实例对象新增的方法有如下：

- copyWithin()

  将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组

- find()、findIndex()

- fill()

- entries()，keys()，values()

- includes()

- flat()，flatMap()



**4. 数组的空位**

数组的空位指，数组的某一个位置没有任何值

ES6 则是明确将空位转为`undefined`，包括`Array.from`、扩展运算符、`copyWithin()`、`fill()`、`entries()`、`keys()`、`values()`、`find()`和`findIndex()`

**5. sort()排序算法稳定性**

将`sort()`默认设置为稳定的排序算法。

