# 代码随想录
## 1.基础题目
## 2.背包
## 3.打家劫舍
## 4.股票
## 5.子序列
	• 子序列，可以是一段不连续的
	• 连续子序列，连续的
	• 子数组就是连续子序列


**392.判断子序列**
```javascript
var isSubsequence = function(s, t) {
    // 动规
    // 思路：题意为判断锁s是否是子序列，利用动规每匹配到一个字符就记录下来，最后统计的长度等于字符串s的长度，则返回true
    // dp[i][j]表示下标为i-1的字符串s和下标为j-1的字符串t的最长公共子序列的长度
    const [m, n] = [s.length, t.length]
    // 重建dp数组
    const dp = new Array(m+1).fill(0).map(()=>new Array(n+1).fill(0))
    for(let i=1; i<=m; i++){
        for(let j=1; j<=n; j++){
            // 当匹配的字符相等则长度+1
            if(s[i-1] === t[j-1]){// 因为初始化从0开始，从1开始遍历
                dp[i][j] = dp[i-1][j-1] + 1
            }else{
                dp[i][j] = dp[i][[j-1]]
            }
        }
    }
    return dp[m][n] === m ? true : false
};
```

**583. 两个字符串的删除操作**
```js
var minDistance = function(word1, word2) {
    // 动规
    // 每次删除一个字符串的一个字符
    /**
    思路：
    1.dp[i][j]下标为i-1的字符串1和下标为j-1的字符串2，所对应的
     */
    // 创建dp数组
    const dp = new Array(word1.length+1).fill(0).map(() => new Array(word2.length).fill(0))
    // 初始化
    for(let i=0; i<= word1.length; i++) dp[i][0] = i
    for(let j=0; j<= word2.length; j++) dp[0][j] = j
    // 循环遍历
    for(let i=1; i<=word1.length; i++){
        for(let j=1; j<=word2.length; j++){
            if(word1[i-1] === word2[j-1]){
                dp[i][j] = dp[i-1][j-1]
            }else{
                dp[i][j] = Math.min(dp[i-1][j-1]+2, dp[i-1][j]+1, dp[i][j-1]+1)
            }
        }
    }
    return dp[word1.length][word2.length]
};
```