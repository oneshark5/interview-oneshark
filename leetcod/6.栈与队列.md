# 知识点

## 栈

### 题目

**232.用栈实现队列**
**225. 用队列实现栈**
**20. 有效的括号**
思路：遇到左括号就把相应的右括号入栈，然后弹栈比较
不匹配的三种情况

1. 第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以 return false
2. 第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以 return false
3. 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false
   方法一：栈模拟

```js
var isValid = function (s) {
  // 栈模拟
  // 遇到左括号就做入栈处理
  const stack = [];
  for (let i = 0; i < s.length; i++) {
    let str = s[i];
    console.log(str);
    if (str === "{") {
      stack.push("}");
    } else if (str === "[") {
      stack.push("]");
    } else if (str === "(") {
      stack.push(")");
    } else if (stack.pop() !== str) {
      return false;
    }
  }
  return stack.length === 0;
};
```

方法二：栈模拟

```js
var isValid = function (s) {
  const stack = [];
  for (let i = 0; i < s.length; i++) {
    let str = s[i];
    switch (str) {
      case "{":
        stack.push("}");
        break;
      case "[":
        stack.push("]");
        break;
      case "(":
        stack.push(")");
        break;
      default:
        if (str !== stack.pop()) {
          return false;
        }
    }
  }
  return stack.length === 0;
};
```

方法三：Map 集合

```js
var isValid = function (s) {
  // Map集合
  /**
    思路:
    1. 建立Map映射
    2. 遍历字符串,如果存在于map集合的key中,做入栈处理;
        如果遍历到的字符不等于栈定元素,返回false
     */
  const stack = [];
  map = {
    "{": "}",
    "[": "]",
    "(": ")",
  };
  for (let str of s) {
    // 可以用来判断键值在不在map集合
    if (str in map) {
      stack.push(str);
      continue;
    }
    if (str !== map[stack.pop()]) return false;
  }
  return !stack.length;
};
```

**1047. 删除字符串中的所有相邻重复项**
方法一：栈模拟
```js
var removeDuplicates = function(s) {
    // 栈处理
    const stack = []
    const strs = s.split('')
    for(let val of strs){
        if(stack.at(-1) === val){
            stack.pop()
        }else{
            stack.push(val)
        }
    }
    return stack.join('')
};
```

方法二：双指针
```js
var removeDuplicates = function(s) {
    // 双指针
    const sArr = s.split('')
    let slow = fast = 0;
    while(fast < s.length){
        sArr[slow] = sArr[fast]
        if(slow > 0 && sArr[slow] === sArr[slow-1]){
            slow--
        }else{
            slow++
        }
        fast++
    }
    return sArr.join('').substr(0,slow)
};
```
方法三：正则表达式
正则不会
```js
var removeDuplicates = function(s) {
    // 正则
    let pat = /([a-z])\1/ // 查找相邻的相同字符串
    while(pat.test(s)) {
        s = s.replace(pat.exec(s)[0], '')
    }
    return s
};
```
**150. 逆波兰表达式求值**\
思路：遍历数组，遇到运算符就弹出栈中上面的两个数进行计算
```js
var evalRPN = function(tokens) {
    // 栈处理：遍历数组，遇到运算符就弹出栈中上面的两个数进行计算
    // 先建立映射，用来处理运算
    const map = {
        '+': (a, b) => b + a,
        '-': (a, b) => b - a,
        '*': (a, b) => b * a,
        '/': (a, b) => (b / a) | 0 // | 0 直接去掉正负数小数点后面的
    }
    const stack = []
    for(let val of tokens){
        if(val in map){
            stack.push(map[val](stack.pop(), stack.pop()))
        }else{
            stack.push(Number(val))
        }
    }
    return stack.at(-1)
};
```
**239. 滑动窗口最大值**
**347.前 K 个高频元素**

## 队列
