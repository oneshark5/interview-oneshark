# 知识点

**模板**
```js
function backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
	// 单层搜索逻辑
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```


## 组合
**77. 组合**
```js
var combine = function(n, k) {
    // 回溯
    const path = []
    const res = []
    const backtracking = (n, k, startIndex) => {
        // 终止条件
        if(path.length === k){
            res.push([...path])
            return
        }
        for(let i=startIndex; i<=n; i++){
            path.push(i)
            backtracking(n, k, i+1)
            path.pop()// 回溯
        }
    }
    backtracking(n, k, 1)
    return res
};
```
⭐剪枝优化
接下来看一下优化过程如下：
1. 已经选择的元素个数：path.size();
2. 还需要的元素个数为: k - path.size();
3. 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历
为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。
举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。
从2开始搜索都是合理的，可以是组合[2, 3, 4]。

**216.组合总和III**
```js
var combinationSum3 = function(k, n) {
    // \U0001f988回溯法:k数之和等于n
    // 剪枝优化:两处需要剪枝,总路径之和大于目标值,半路上就大于目标值
    // \U0001f988用数组去处理:当数组长度为k并且之和为n时,才存放结果---先不剪枝优化
    let path = []// 已获得元素之和
    let res = []
    const backtracking = (k, startIndex)=>{
        if(path.length === k){
            let arrSum = path.reduce((total,curIndex)=>{
                return total + curIndex
            })
            if(arrSum === n) res.push([...path])
            return
        }
        for(let i=startIndex; i<=9; i++){
            path.push(i)//处理
            backtracking(k, i+1)//递归
            path.pop()//回溯
        }
    }
    backtracking(k, 1)
    return res
};
```

⭐剪枝优化
```js
var combinationSum3 = function(k, n) {
    // 剪枝优化
    // 优化一：每一层for循环的起始位置 i <= 9-(k - path.length) + 1
    // 优化二：求和大于目标值
    const path = []
    const res = []
    const backtracking = (targetSum, k, startIndex) => {
        if(targetSum < 0) return // 优化1
        if(path.length === k && targetSum === 0){
            res.push([...path])
            return
        }
        for(let i=startIndex; i<=9-(k-path.length)+1; i++){// 优化2
            path.push(i)
            backtracking(targetSum-i, k, i+1)
            path.pop()
        }
    }
    backtracking(n, k, 1)
    return res
};
```
**17.电话号码的字母组合**
**39. 组合总和**
**40.组合总和II**


**131.分割回文串**
**93.复原IP地址**


## 子集
**78.子集**
**491.递增子序列**

## 排列
**46.全排列**
**47.全排列 II**
**332.重新安排行程**
**第51题. N皇后**
**37. 解数独**

## 岛屿问题
****
****
****