## 知识点

**位运算**

[参考](https://juejin.cn/post/6923563274822746126)

二进制位异或运算相当于对应位相加，不考虑进位

| 运算符 | 名称         | 描述                                                     |
| :----- | :----------- | :------------------------------------------------------- |
| &      | AND          | 如果两位都是 1 则设置每位为 1                            |
| \|     | OR           | 如果两位之一为 1 则设置每位为 1                          |
| ^      | XOR          | 如果两位只有一位为 1 则设置每位为 1                      |
| ~      | NOT          | 反转所有位                                               |
| <<     | 零填充左位移 | 通过从右推入零向左位移，并使最左边的位脱落。             |
| >>     | 有符号右位移 | 通过从左推入最左位的拷贝来向右位移，并使最右边的位脱落。 |
| >>>    | 零填充右位移 | 通过从左推入零来向右位移，并使最右边的位脱落。           |

**位运算相关题目**

**[参考](https://leetcode.cn/problems/sum-of-two-integers/solution/gong-shui-san-xie-shi-yong-wei-yun-suan-4hpb7/)**
**剑指 Offer II 002. 二进制加法**

**[371. 两整数之和](https://leetcode.cn/problems/sum-of-two-integers/)**

使用异或 ^ 运算符的话，需要额外处理进位的情况， 即两个二进制位都为1a + b，我们可以转化为：a + b无进位的值 + a + b的进位，即：

- a + b，我们可以转化为：a + b无进位的值 + a + b的进位，即：
- a + b = (a ^ b) + ((a & b) << 1)
- 利用这个公式将 a + b转化为另外两个数的加法。
- `b = a & b << 1`，上步结果左移，实现进`1`位

```js
var getSum = function(a, b) {
    let sum = a
    let carry = 0
    while(b){
        sum = a ^ b // 不进位得值
        carry = (a & b) << 1 // 进位，左移一位
        a = sum
        b = carry
    }
    return sum
};
```

# 🐦飞鸟
**剑指 Offer 04. 二维数组中的查找**
🦈先铺平再采用二分查找，二分有两种 非递归和递归  这里都没跑出来
```js
var findNumberIn2DArray = function(matrix, target) {
    // 判断元素是否在二维数组中
    // 🦈将二维数组铺平，采用二分查找==》学习下搜索算法⭐⭐⭐
    // 二分查找法，分为递归和非递归
    // ⭐⭐⭐非递归
    // const arr = matrix.flat()
    // const binarySearch = (arr, left, right) => {
    //     while(left <= right){
    //         let mid = Math.round((left + right) / 2)// 计算的是索引值
    //         if(arr[mid] === target){
    //             return mid // 返回找到的索引值
    //         }else if(arr[mid] < target){
    //             left = mid + 1
    //         }else{
    //             right = mid - 1
    //         }
    //     }
    //     return -1
    // }
    // let midIndex = binarySearch(arr, 0, arr.length)
    // return midIndex > -1 ? true : false

    // ⭐⭐⭐递归
    // const arr = matrix.flat()
    // const binarySearch = (arr, left, right, target) => {
    //     let midIndex = Math.floor((left + right) / 2)
    //     let midVal = arr[midIndex]
    //     if(midVal < target){
    //         return binarySearch(arr, midVal + 1, right, target)
    //     }else if(midVal > target){
    //         return binarySearch(arr, left, midVal - 1, target )
    //     }else{
    //         return midVal
    //     }
    // }
    // let mid = binarySearch(arr, 0, arr.length-1, target)
    // return mid === target


    // 🐦直接在二维数组上采用二分查找
    const [m, n] = [matrix.length, matrix[0]?.length]
    if(!m) return false
    let [row, col] = [m-1, 0]
    while(row >= 0 && col <= n-1){
        if(matrix[row][col] > target) row--
        else if(matrix[row][col] < target) col++
        else return true
    }
    return false
};
```
🐦答案
```js
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var findNumberIn2DArray = function(matrix, target) {
    // 暴力解法
    // for(let i=0; i<matrix.length; i++){
    //     for(let j=0; j<matrix[i].length; j++){
    //         if(matrix[i][j] === target) return true
    //     }
    // }
    // return false
    
    // 双指针
    /**
    思路：从左下角开始，小就向右移动，大就向上移动
     */
    const [m, n] = [matrix.length, matrix[0]?.length]
    if(!m) return false
    let [row, col] = [m-1, 0]
    while(row>=0 && col<=n-1){
        if(matrix[row][col] === target) return true
        else if(matrix[row][col] > target) row--
        else col++
    }
    return false
};
```
**剑指 Offer 11. 旋转数组的最小数字**
将数组开始的 几个元素 进行了一次旋转  找最小值
```js
var minArray = function(numbers) {
    // 借用Api
    // numbers.sort((a,b) => a-b)
    // return numbers[0]

    // 二分查找
    /**
    思路：计算mid
    1.如果mid>right，则最小值在右侧，left=mid+1
    2.如果mid<right，则最小值在左侧或者mid就是最小值 right = mid
    3.如果mid=right，此时左右不确定，从最右边减1继续计算。right--;
     */
    let [left, right] = [0, numbers.length-1]
    while(left <= right){
        let mid = Math.floor((left+right)/2)
        if(numbers[mid] > numbers[right]) left = mid + 1 // 最小值在右侧
        else if(numbers[mid] < numbers[left]) right = mid
        else right--
    }
    return numbers[left]
};
```

**剑指 Offer 53 - I. 在排序数组中查找数字 I**
```js
var search = function(nums, target) {
    // 直接for循环
    let count = 0
    for(let ele of nums){
        if(target === ele) count++
    }
    return count
};
```
* 二分查找
```js
var search = function(nums, target) {
    // 二分法：优化---有点意思
    // 要看清给定的条件，这里已经说明是排序后的数组，所以如果有多个target，它在数组中是连续的
    /**
    思路：
    1.首先，二分查找，找到等于target的中间值
    2.然后，从中间值开始向两侧扩散
    3.标记最左侧和最右侧的位置，然后进行计算
     */
    let [left, right, flag] = [0, nums.length-1, null]
    while(left <= right){
        let mid = Math.floor((left+right)/2)
        let midNum = nums[mid]
        if(midNum > target){
            right = mid - 1
        }else if(midNum < target){
            left = mid + 1
        }else{
            // 找到一个就标记并退出循环
            flag = mid
            break
        }
    }
    // 当退出循环，flag仍为空则无数组中未出现target---注意这里不能写成(!flage)因为0也会转成false
    if(flag === null) return 0
    // 从flag向两侧扩散
    left = right = flag
    while(nums[left-1] === target) left--
    while(nums[right+1] === target) right++
    return right-left+1
};
```

**剑指 Offer 53 - II. 0～n-1中缺失的数字**
🦈直接for循环,但是要排除两个特殊情况,一是第一个值不为0,二是最后一个值缺失
```js
var missingNumber = function(nums) {
    // 直接for循环:排除索引0处不为0的情况和最后一个值确实的情况
    if(nums[0] === 1) return 0
    for(let i=0; i<nums.length; i++){
        if(nums[i] !== i) return i
    }
    return nums.length
};
```
采用二分查找，根据中间值判断缺失数字是在左边还是右边
有序数组 ——> 二分查找
* nums[mid] === mid：左半边完整，缩小范围，开始找右半边
* nums[mid] !== mid：左半边不完整，缩小范围，在左半边找
```js
var missingNumber = function(nums) {
    // 二分查找
    // 有意思,通过判断中间值就知道左边有没有问题
    let [left, right] = [0, nums.length-1]
    while(left <= right){
        let mid = (left+right) >> 1
        if(nums[mid] === mid){ //左边没有问题
            left = mid + 1
        }else{//左边有问题
            right = mid - 1
        }
    }
    return left
};
```