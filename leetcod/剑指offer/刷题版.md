## 知识点

**位运算**

[参考](https://juejin.cn/post/6923563274822746126)

二进制位异或运算相当于对应位相加，不考虑进位

| 运算符 | 名称         | 描述                                                     |
| :----- | :----------- | :------------------------------------------------------- |
| &      | AND          | 如果两位都是 1 则设置每位为 1                            |
| \|     | OR           | 如果两位之一为 1 则设置每位为 1                          |
| ^      | XOR          | 如果两位只有一位为 1 则设置每位为 1                      |
| ~      | NOT          | 反转所有位                                               |
| <<     | 零填充左位移 | 通过从右推入零向左位移，并使最左边的位脱落。             |
| >>     | 有符号右位移 | 通过从左推入最左位的拷贝来向右位移，并使最右边的位脱落。 |
| >>>    | 零填充右位移 | 通过从左推入零来向右位移，并使最右边的位脱落。           |

**位运算相关题目**

**[参考](https://leetcode.cn/problems/sum-of-two-integers/solution/gong-shui-san-xie-shi-yong-wei-yun-suan-4hpb7/)**
**剑指 Offer II 002. 二进制加法**

**[371. 两整数之和](https://leetcode.cn/problems/sum-of-two-integers/)**

使用异或 ^ 运算符的话，需要额外处理进位的情况， 即两个二进制位都为 1a + b，我们可以转化为：a + b 无进位的值 + a + b 的进位，即：

- a + b，我们可以转化为：a + b 无进位的值 + a + b 的进位，即：
- a + b = (a ^ b) + ((a & b) << 1)
- 利用这个公式将 a + b 转化为另外两个数的加法。
- `b = a & b << 1`，上步结果左移，实现进`1`位

```js
var getSum = function (a, b) {
  let sum = a;
  let carry = 0;
  while (b) {
    sum = a ^ b; // 不进位得值
    carry = (a & b) << 1; // 进位，左移一位
    a = sum;
    b = carry;
  }
  return sum;
};
```

# 🐦 飞鸟

## 二分查找

**剑指 Offer 04. 二维数组中的查找**
🦈 先铺平再采用二分查找，二分有两种 非递归和递归 这里都没跑出来

```js
var findNumberIn2DArray = function (matrix, target) {
  // 判断元素是否在二维数组中
  // 🦈将二维数组铺平，采用二分查找==》学习下搜索算法⭐⭐⭐
  // 二分查找法，分为递归和非递归
  // ⭐⭐⭐非递归
  // const arr = matrix.flat()
  // const binarySearch = (arr, left, right) => {
  //     while(left <= right){
  //         let mid = Math.round((left + right) / 2)// 计算的是索引值
  //         if(arr[mid] === target){
  //             return mid // 返回找到的索引值
  //         }else if(arr[mid] < target){
  //             left = mid + 1
  //         }else{
  //             right = mid - 1
  //         }
  //     }
  //     return -1
  // }
  // let midIndex = binarySearch(arr, 0, arr.length)
  // return midIndex > -1 ? true : false

  // ⭐⭐⭐递归
  // const arr = matrix.flat()
  // const binarySearch = (arr, left, right, target) => {
  //     let midIndex = Math.floor((left + right) / 2)
  //     let midVal = arr[midIndex]
  //     if(midVal < target){
  //         return binarySearch(arr, midVal + 1, right, target)
  //     }else if(midVal > target){
  //         return binarySearch(arr, left, midVal - 1, target )
  //     }else{
  //         return midVal
  //     }
  // }
  // let mid = binarySearch(arr, 0, arr.length-1, target)
  // return mid === target

  // 🐦直接在二维数组上采用二分查找
  const [m, n] = [matrix.length, matrix[0]?.length];
  if (!m) return false;
  let [row, col] = [m - 1, 0];
  while (row >= 0 && col <= n - 1) {
    if (matrix[row][col] > target) row--;
    else if (matrix[row][col] < target) col++;
    else return true;
  }
  return false;
};
```

🐦 答案

```js
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var findNumberIn2DArray = function (matrix, target) {
  // 暴力解法
  // for(let i=0; i<matrix.length; i++){
  //     for(let j=0; j<matrix[i].length; j++){
  //         if(matrix[i][j] === target) return true
  //     }
  // }
  // return false

  // 双指针
  /**
    思路：从左下角开始，小就向右移动，大就向上移动
     */
  const [m, n] = [matrix.length, matrix[0]?.length];
  if (!m) return false;
  let [row, col] = [m - 1, 0];
  while (row >= 0 && col <= n - 1) {
    if (matrix[row][col] === target) return true;
    else if (matrix[row][col] > target) row--;
    else col++;
  }
  return false;
};
```

**剑指 Offer 11. 旋转数组的最小数字**
将数组开始的 几个元素 进行了一次旋转 找最小值

```js
var minArray = function (numbers) {
  // 借用Api
  // numbers.sort((a,b) => a-b)
  // return numbers[0]

  // 二分查找
  /**
    思路：计算mid
    1.如果mid>right，则最小值在右侧，left=mid+1
    2.如果mid<right，则最小值在左侧或者mid就是最小值 right = mid
    3.如果mid=right，此时左右不确定，从最右边减1继续计算。right--;
     */
  let [left, right] = [0, numbers.length - 1];
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (numbers[mid] > numbers[right]) left = mid + 1; // 最小值在右侧
    else if (numbers[mid] < numbers[left]) right = mid;
    else right--;
  }
  return numbers[left];
};
```

**剑指 Offer 53 - I. 在排序数组中查找数字 I**

```js
var search = function (nums, target) {
  // 直接for循环
  let count = 0;
  for (let ele of nums) {
    if (target === ele) count++;
  }
  return count;
};
```

- 二分查找

```js
var search = function (nums, target) {
  // 二分法：优化---有点意思
  // 要看清给定的条件，这里已经说明是排序后的数组，所以如果有多个target，它在数组中是连续的
  /**
    思路：
    1.首先，二分查找，找到等于target的中间值
    2.然后，从中间值开始向两侧扩散
    3.标记最左侧和最右侧的位置，然后进行计算
     */
  let [left, right, flag] = [0, nums.length - 1, null];
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    let midNum = nums[mid];
    if (midNum > target) {
      right = mid - 1;
    } else if (midNum < target) {
      left = mid + 1;
    } else {
      // 找到一个就标记并退出循环
      flag = mid;
      break;
    }
  }
  // 当退出循环，flag仍为空则无数组中未出现target---注意这里不能写成(!flage)因为0也会转成false
  if (flag === null) return 0;
  // 从flag向两侧扩散
  left = right = flag;
  while (nums[left - 1] === target) left--;
  while (nums[right + 1] === target) right++;
  return right - left + 1;
};
```

**剑指 Offer 53 - II. 0 ～ n-1 中缺失的数字**
🦈 直接 for 循环,但是要排除两个特殊情况,一是第一个值不为 0,二是最后一个值缺失

```js
var missingNumber = function (nums) {
  // 直接for循环:排除索引0处不为0的情况和最后一个值确实的情况
  if (nums[0] === 1) return 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== i) return i;
  }
  return nums.length;
};
```

采用二分查找，根据中间值判断缺失数字是在左边还是右边
有序数组 ——> 二分查找

- nums[mid] === mid：左半边完整，缩小范围，开始找右半边
- nums[mid] !== mid：左半边不完整，缩小范围，在左半边找

```js
var missingNumber = function (nums) {
  // 二分查找
  // 有意思,通过判断中间值就知道左边有没有问题
  let [left, right] = [0, nums.length - 1];
  while (left <= right) {
    let mid = (left + right) >> 1;
    if (nums[mid] === mid) {
      //左边没有问题
      left = mid + 1;
    } else {
      //左边有问题
      right = mid - 1;
    }
  }
  return left;
};
```

## 双指针

**剑指 Offer 05. 替换空格**
思路：

1. 统计空格数量
2. 更新数组长度
3. 定义双指针，l 指向原数组， r 指向新数组
4. 遇到' '右指针一次赋值% 2 0，非空则把左指针的值赋值给有指针

```js
var replaceSpace = function (s) {
  // 将字符串转成数组
  // 快慢双指针从后往前遍历；相当于两个指针指向了两个数组
  const arr = s.split("");
  const len = arr.length;
  let count = 0;
  for (let str of s) {
    if (str === " ") count++;
  }
  arr.length += 2 * count;
  // 定义双指针
  let [l, r] = [len - 1, arr.length - 1];
  while (l >= 0) {
    if (arr[l] !== " ") {
      arr[r] = arr[l];
    } else {
      arr[r] = "0";
      arr[r - 1] = "2";
      arr[r - 2] = "%";
      r -= 2;
    }
    // 处理完一个字符都要左移
    l--;
    r--;
  }
  return arr.join("");
};
```

**剑指 Offer 21. 调整数组顺序使奇数位于偶数前面**

```js
var exchange = function (nums) {
  // 指定左右指针
  // 左指针查找到偶数停止，右指针查找到奇数停止
  // 左右指针交换
  let [left, right] = [0, nums.length - 1];
  while (left < right) {
    while (left < right && nums[left] & 1) left++;
    while (left < right && !(nums[right] & 1)) right--;
    [nums[left], nums[right]] = [nums[right], nums[left]];
  }
  return nums;
};
```

**剑指 Offer 22. 链表中倒数第 k 个节点**

```js
var getKthFromEnd = function (head, k) {
  // 快慢双指针
  // 思路：快指针先走k步，然后快慢指针一起走
  // 创建虚拟头节点
  const newNode = new ListNode(0);
  // 虚拟头节点指向头节点
  newNode.next = head;
  let slow = (fast = newNode);
  for (let i = 0; i < k; i++) {
    fast = fast.next;
  }
  while (fast) {
    fast = fast.next;
    slow = slow.next;
  }
  return slow;
};
```

**剑指 Offer 25. 合并两个排序的链表**
思路：

1. 创建虚拟头节点，并定义一个指针指向其头部
2. 创建 p1，p2 两个指针，指向两链表头部，一起遍历
3. 条件判断，p1 和 p2 哪个对应的值小，哪个就连接到答案链表

```js
var mergeTwoLists = function (l1, l2) {
  // 合并链表，向一个链表中加入另一个链表，保持顺序不变
  const newNode = new ListNode(0);
  let p = newNode;
  let [p1, p2] = [l1, l2];
  while (p1 && p2) {
    if (p1.val < p2.val) {
      p.next = p1;
      p1 = p1.next;
    } else {
      p.next = p2;
      p2 = p2.next;
    }
    p = p.next;
  }
  // 最后，跳出循环是p1 p2有一个为null，其中一个链表的一个节点还未添加到结果
  p.next = p1 ? p1 : p2;
  return newNode.next;
};
```

**剑指 Offer 57. 和为 s 的两个数字**
**剑指 Offer 57 - II. 和为 s 的连续正数序列**

- 滑动窗口思路，窗口初始化为[1, 2]，初始 sum 为 3
- 因为输出的序列至少有 2 个数，所以若窗口第一个数大于 target/2 时，就不再继续了
- 若 sum 太小，向窗口添加下一个数，更新 sum
- 若 sum 太大，弹出窗口第一个数，更新 sum
- 若 sum===target，则将窗口的数放入 res，随后弹出第一个数，继续滑动

```js
var findContinuousSequence = function (target) {
  // 滑动窗口（好题）
  const res = [];
  const window = [1, 2];
  let sum = 3; // 求和用于和target比较
  while (window[0] <= target >> 1) {
    if (sum < target) {
      // 新增值
      const num = window.at(-1) + 1;
      sum += num;
      window.push(num);
    } else if (sum > target) {
      sum -= window.shift();
    } else {
      res.push([...window]);
      sum -= window.shift();
    }
  }
  return res;
};
```

## Map()集合

**剑指 Offer 50. 第一个只出现一次的字符**

```js
var firstUniqChar = function (s) {
  // 借用indexOf()方法，查找元素第一次出现的索引值，没有则返回-1
  for (let i = 0; i < s.length; i++) {
    // 对遍历到元素，查找第一次出现时的索引值
    let firstInd = s.indexOf(s[i]);
    // 从查找到的第一个位置后面再次查找
    let sedInd = s.indexOf(s[i], firstInd + 1);
    // 如果后面都没有，则该值就是所要的结果
    if (sedInd === -1) return s[i];
  }
  return " ";
};
```

Map 集合

```js
var firstUniqChar = function (s) {
  // 思路：遍历字符串，记录字符出现的次数
  const map = new Map();
  let res = " ";
  for (let str of [...s]) {
    map.set(str, (map.get(str) || 0) + 1);
  }
  // 再次遍历把第一个出现次数为 1 的输出
  for (let str of s) {
    if (map.get(str) === 1) {
      res = str;
      break;
    }
  }
  return res;
};
```

**剑指 Offer 56 - II. 数组中数字出现的次数 II**

```js
var singleNumber = function (nums) {
  // 50T是统计的次数  这里统计是哪个数字
  // 方法一：indexOf
  // let res
  // for(let num of nums){
  //     let firstIndex = nums.indexOf(num)
  //     let secondIndex = nums.indexOf(num, firstIndex+1)
  //     if(secondIndex === -1) res = num
  // }
  // return res

  // 方法二：Map集合
  const map = new Map();
  let res;
  for (let num of nums) {
    map.set(num, (map.get(num) || 0) + 1);
  }
  for (let num of nums) {
    if (map.get(num) === 1) {
      res = num;
      break;
    }
  }
  return res;
};
```

## 链表

**剑指 Offer 06. 从尾到头打印链表**

```js
var reversePrint = function (head) {
  // 方法一：转换成数组
  // const arr = []
  // while(head){
  //     arr.push(head.val)
  //     head = head.next
  // }
  // return arr.reverse()
  // 方法二：反转链表
  let [cur, pre] = [head, null];
  while (cur !== null) {
    let temp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  // 对反转后的链表进行遍历
  const res = [];
  while (pre) {
    res.push(pre.val);
    pre = pre.next;
  }
  return res;
};
```

**剑指 Offer 18. 删除链表的节点**

```js
var deleteNode = function (head, val) {
  // 设置虚拟头节点，易于遍历
  let newNode = new ListNode(0);
  newNode.next = head;
  let curNode = newNode;
  while (curNode && curNode.next) {
    if (curNode.next.val === val) {
      curNode.next = curNode.next.next;
    } else {
      curNode = curNode.next;
    }
  }
  return newNode.next;
};
```

**剑指 Offer 24. 反转链表**

```js
var reverseList = function (head) {
  // 反转链表
  let [cur, pre] = [head, null];
  while (cur) {
    // 反转处理
    let temp = cur.next;
    cur.next = pre;
    // 理解为更新节点
    pre = cur;
    cur = temp;
  }
  return pre;
};
```

**剑指 Offer 35. 复杂链表的复制**
思路：

- 第一次遍历，复制节点值，key 和 val 都为链表的值
- 第二次遍历，复制节点关系，包含 next 指针和 random 指针

```js
var copyRandomList = function (head) {
  // map映射
  const map = new Map();
  // 第一次遍历
  let curNode = head;
  while (curNode) {
    // ???这里为什么加入的是new Node(curNode.val)？？？新节点
    map.set(curNode, new Node(curNode.val));
    curNode = curNode.next;
  }
  // 第二次遍历，复制指针关系
  curNode = head;
  while (curNode) {
    map.get(curNode).next = map.get(curNode.next) || null; // next指针
    map.get(curNode).random = map.get(curNode.random) || null; // random指针
    curNode = curNode.next;
  }
  return map.get(head);
};
```

**剑指 Offer 36. 二叉搜索树与双向链表**

```js
var treeToDoublyList = function (root) {
  // 排序的循环双向链表:第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
  // 不熟
  // 递归中序遍历
  const dfs = (cur) => {
    if (!cur) return;
    dfs(cur.left);
    if (!pre) {
      head = cur;
    } else {
      // pre有值，更新指针，双向连接
      pre.right = cur;
      cur.left = pre;
    }
    pre = cur;
    dfs(cur.right);
  };

  let pre, head;
  if (!root) return;
  dfs(root);
  // 首尾相连---最后跳出循环时，pre为最后一个节点为最右边的
  head.left = pre;
  pre.right = head;
  return head;
};
```

**剑指 Offer 52. 两个链表的第一个公共节点**

```js
var getIntersectionNode = function (headA, headB) {
  /**
    思路：两个链表互相遍历  (a+c) + b = (b+c) + a   两链表肯定会相交
    - 若
     */
  let [nodeA, nodeB] = [headA, headB];
  while (nodeA !== nodeB) {
    nodeA = nodeA === null ? headB : nodeA.next;
    nodeB = nodeB === null ? headA : nodeB.next;
  }
  return nodeA;
};
```

## 递归

### 构造二叉树

已知结论：

1. 中：根节点左右为左右子树
2. 后：最后一个元素为树的根节点
3. 前：第一个元素为树的根节点
   代码随想录：
   第一步：如果数组大小为零的话，说明是空节点了。
   第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
   第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
   第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
   第五步：切割后序数组，切成后序左数组和后序右数组
   第六步：递归处理左区间和右区间

🦈：
①. 指针交错或数组大小为空，返回 null
②. 获取后序遍历数组的最后一个元素作为二叉树的根节点
③. 确定根节点在中序遍历中的索引位置
④. 根据索引位置分割左右子树，计算左子树的长度（用于求后序中左右子树）
递归创建左右子树
**106. 从中序与后序遍历序列构造二叉树**

```js
var buildTree = function (inorder, postorder) {
  // 递归     左闭右闭
  /**
  思路分析：
  1.根据后序遍历数组最后一个元素获取根节点
  2.确定根节点元素在中序遍历数组中的位置
  3.确定左子树长度-->用来分隔后序遍历的左右子树
   */
  //  将中序遍历索引值保存-->更好的索引根节点元素在中序遍历数组中的位置
  const map = {};
  for (let i = 0; i < inorder.length; i++) {
    map[inorder[i]] = i;
  }
  // 定义递归函数
  const createTree = (iStart, iEnd, pStart, pEnd) => {
    // 确定终止条件
    if (pStart > pEnd || iStart > iEnd) return null;
    const rootVal = postorder[pEnd]; //获取根节点元素
    const minIndex = map[rootVal]; //获取根节点元素在中序遍历的索引值
    const leftNodeLength = minIndex - iStart; //获取左子树长度

    // 创建节点
    const root = new TreeNode(rootVal);
    // 递归
    root.left = createTree(
      iStart,
      minIndex - 1,
      pStart,
      pStart + leftNodeLength - 1
    );
    root.right = createTree(
      minIndex + 1,
      iEnd,
      pStart + leftNodeLength,
      pEnd - 1
    ); //递归构建右子树  不包含最后一个节点(根元素)
    return root;
  };
  return createTree(0, inorder.length - 1, 0, postorder.length - 1);
};
```

**剑指 Offer 07. 重建二叉树**

```js
var buildTree = function (preorder, inorder) {
  // 根据已知条件，确定根节点和左右子树，然后再递归确定左右子树
  // 建立映射
  const map = {};
  for (let i = 0; i < inorder.length; i++) {
    map[inorder[i]] = i;
  }
  // 递归
  const createTree = (preStart, preEnd, iStart, iEnd) => {
    // 确定终止条件
    if (preStart > preEnd || iStart > iEnd) return null;
    const rootVal = preorder[preStart]; // 确定根节点
    const rootIndex = map[rootVal]; // 确定根节点在中序遍历中的位置（索引值）
    const leftNodeLength = rootIndex - iStart; // 确定左子树长度

    // 创建节点
    const root = new TreeNode(rootVal);
    root.left = createTree(
      preStart + 1,
      preStart + leftNodeLength,
      iStart,
      rootIndex - 1
    );
    root.right = createTree(
      preStart + leftNodeLength + 1,
      preEnd,
      rootIndex + 1,
      iEnd
    );
    return root;
  };
  return createTree(0, preorder.length - 1, 0, inorder.length - 1);
};
```

**剑指 Offer 16. 数值的整数次方**
思路：

- 递归出口：n 为 0，返回 1
- 若 n 小于 0，特殊处理
- 若 n 为奇数，算 myPow(x, n - 1)，转化为偶数
- 若 n 为偶数，算 myPow(x \* x, n / 2)

```js
const myPow = (x, n) => {
  // 递归出口
  if (n === 0) return 1;
  // n小于0，特殊情况
  if (n < 0) return 1 / myPow(x, -n);
  // n奇数
  if (n & 1) return x * myPow(x, n - 1);
  // n偶数
  return myPow(x * x, n / 2);
};
```

**剑指 Offer 26. 树的子结构**
思路：

- A 空或 B 空，返回 false
- 递归判断 A 当前节点、A 左子树、A 右子树任意一个与 B 相同，就返回 true

```js
// 该递归函数是用来判断A当前节点和B是否相同
const dfs = (A, B) => {
  // 递归出口
  if (!B) return true;
  // A空，B不为空，false
  if (!A) return false;
  return A.val === B.val && dfs(A.left, B.left) && dfs(A.right, B.right);
};

const isSubStructure = (A, B) => {
  // 递归出口，A空或B空，false
  if (!A || !B) return false;
  // 递归判断A当前节点、A左子树、A右子树任意一个与B相同，就返回true
  return dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
};
```

**剑指 Offer 27. 二叉树的镜像**

```js
var mirrorTree = function (root) {
  // 根节点不变，交换左右子树
  // BFS
  // 🦈层序遍历，遍历一层后反转加入数组
  // const res = []
  // if(!root) return res
  // const queueNode = [root]
  // while(queueNode.length){
  //     // 保存一层节点
  //     const levelNode = []
  //     const len = queueNode.length
  //     for(let i=1; i<=len; i++){
  //         let node = queueNode.shift()
  //         levelNode.unshift(node.val)
  //         node.left && queueNode.push(node.left)
  //         node.right && queueNode.push(node.right)
  //     }
  //     res.push(levelNode)
  // }
  // return res.flat()

  // 🐦
  // 方法二⭐⭐
  // 递归出口
  if (!root) return null;
  // 交换当前左右节点
  [root.left, root.right] = [root.right, root.left];
  // 递归交换左子树的左右节点
  mirrorTree(root.left);
  // 递归交换右子树的左右节点
  mirrorTree(root.right);
  // 返回当前节点给上一级
  return root;

  // 方法三⭐⭐⭐
  if (!root) return null;

  const node = new TreeNode(root.val);

  node.left = mirrorTree(root.right);
  node.right = mirrorTree(root.left);

  return node;
};
```

**剑指 Offer 28. 对称的二叉树**
DFS
判断一个二叉树是否对称，只需判断二叉树的两个子树是否镜像即可。 镜像的条件：

1. 节点值相等
2. node1 的左子树和 node2 的右子树是镜像
3. node1 的右子树和 node2 的左子树是镜像

```js
const isSymmetric = (root) => {
  if (!root) return true;
  // 判断两个二叉树是否镜像
  const check = (node1, node2) => {
    // 两个空树，true
    if (!node1 && !node2) return true;
    // 只有一个空树，false
    if (!node1 || !node2) return false;
    // 镜像的条件：
    // 1. 节点值相等
    // 2. node1的左子树和node2的右子树是镜像
    // 3. node1的右子树和node2的左子树是镜像
    return (
      node1.val === node2.val &&
      check(node1.left, node2.right) &&
      check(node1.right, node2.left)
    );
  };
  // 判断树的两个子树是否镜像即可
  return check(root.left, root.right);
};
```

BFS

```js
const isSymmetric = (root) => {
  if (!root) return true;
  // 根节点的左右节点入队
  const queue = [root.left, root.right];
  while (queue.length) {
    // 当前队列的长度
    const len = queue.length;
    // 每次对比两个节点，所以i=i+2
    for (let i = 0; i < len; i += 2) {
      // 两个节点出队
      const left = queue.shift();
      const right = queue.shift();
      // 有一个为空，另一个不为空，直接返回false
      if ((left && !right) || (!left && right)) return false;
      // 两节点都不为空
      if (left && right) {
        // 值不相等，返回false
        if (left.val !== right.val) return false;
        // 将两个节点的左右节点，按照对应关系入队
        queue.push(left.left, right.right, left.right, right.left);
      }
    }
  }
  // 遍历结束返回true
  return true;
};
```

**剑指 Offer 33. 二叉搜索树的后序遍历序列**
给定一个数组，判断是不是后序遍历数组
🐦
此题中输入的数组的任意两个数字都互不相同，所以此题的二叉搜索树的左子树节点都小于根节点，右子树节点都大于根节点。

- 后序遍历，最后一个是根节点
- 找到第一个大于根节点的位置 i
- 从 i 开始，判断 i 右边到根节点之间的元素，是否都大于根节点值，若否，直接返回 false；若是，递归判断左右子树

```js
const verifyPostorder = (postorder) => {
  const len = postorder.length;
  // 递归出口
  if (len <= 1) return true;
  // 后序遍历，最后一个是根节点
  const root = postorder[len - 1];
  // 找到第一个大于根节点的位置i
  let i = 0;
  while (postorder[i] < root) i++;
  // 从i开始，判断i右边到根节点之间的元素，也就是右子树是否都大于根节点值
  const res = postorder.slice(i, len - 1).every((x) => x > root);
  // 若否，直接返回false
  // 若是，递归判断左右子树
  return res
    ? verifyPostorder(postorder.slice(0, i)) &&
        verifyPostorder(postorder.slice(i, len - 1))
    : false;
};
```

**剑指 Offer 38. 字符串的排列**
**剑指 Offer 55 - II. 平衡二叉树**
在求二叉树的深度函数的代码上稍作修改即可：

若左子树返回-1，或右子树返回-1，或者高度差的绝对值大于1，就返回-1
否则就返回当前节点数的深度
```js
const isBalanced = root => {
    // 如果返回-1，则该节点不平衡
    const check = node => {
        if (!node) return 0;
        const left = check(node.left);
        const right = check(node.right);
        if (left === -1 || right === -1 || Math.abs(left - right) > 1) {
            return -1;
        }
        return Math.max(left, right) + 1;// ⭐？？？？
    };
    // 若等于-1，则不是平衡二叉树
    return check(root) !== -1;
};
```
**剑指 Offer 64. 求 1+2+…+n**
**剑指 Offer 68 - II. 二叉树的最近公共祖先**
