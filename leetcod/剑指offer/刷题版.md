## 知识点

**位运算**

[参考](https://juejin.cn/post/6923563274822746126)

二进制位异或运算相当于对应位相加，不考虑进位

| 运算符 | 名称         | 描述                                                     |
| :----- | :----------- | :------------------------------------------------------- |
| &      | AND          | 如果两位都是 1 则设置每位为 1                            |
| \|     | OR           | 如果两位之一为 1 则设置每位为 1                          |
| ^      | XOR          | 如果两位只有一位为 1 则设置每位为 1                      |
| ~      | NOT          | 反转所有位                                               |
| <<     | 零填充左位移 | 通过从右推入零向左位移，并使最左边的位脱落。             |
| >>     | 有符号右位移 | 通过从左推入最左位的拷贝来向右位移，并使最右边的位脱落。 |
| >>>    | 零填充右位移 | 通过从左推入零来向右位移，并使最右边的位脱落。           |

**位运算相关题目**

**[参考](https://leetcode.cn/problems/sum-of-two-integers/solution/gong-shui-san-xie-shi-yong-wei-yun-suan-4hpb7/)**
**剑指 Offer II 002. 二进制加法**

**[371. 两整数之和](https://leetcode.cn/problems/sum-of-two-integers/)**

使用异或 ^ 运算符的话，需要额外处理进位的情况， 即两个二进制位都为 1a + b，我们可以转化为：a + b 无进位的值 + a + b 的进位，即：

- a + b，我们可以转化为：a + b 无进位的值 + a + b 的进位，即：
- a + b = (a ^ b) + ((a & b) << 1)
- 利用这个公式将 a + b 转化为另外两个数的加法。
- `b = a & b << 1`，上步结果左移，实现进`1`位

```js
var getSum = function (a, b) {
  let sum = a;
  let carry = 0;
  while (b) {
    sum = a ^ b; // 不进位得值
    carry = (a & b) << 1; // 进位，左移一位
    a = sum;
    b = carry;
  }
  return sum;
};
```

# 🐦 飞鸟

## 二分查找

**剑指 Offer 04. 二维数组中的查找**
🦈 先铺平再采用二分查找，二分有两种 非递归和递归 这里都没跑出来

```js
var findNumberIn2DArray = function (matrix, target) {
  // 判断元素是否在二维数组中
  // 🦈将二维数组铺平，采用二分查找==》学习下搜索算法⭐⭐⭐
  // 二分查找法，分为递归和非递归
  // ⭐⭐⭐非递归
  // const arr = matrix.flat()
  // const binarySearch = (arr, left, right) => {
  //     while(left <= right){
  //         let mid = Math.round((left + right) / 2)// 计算的是索引值
  //         if(arr[mid] === target){
  //             return mid // 返回找到的索引值
  //         }else if(arr[mid] < target){
  //             left = mid + 1
  //         }else{
  //             right = mid - 1
  //         }
  //     }
  //     return -1
  // }
  // let midIndex = binarySearch(arr, 0, arr.length)
  // return midIndex > -1 ? true : false

  // ⭐⭐⭐递归
  // const arr = matrix.flat()
  // const binarySearch = (arr, left, right, target) => {
  //     let midIndex = Math.floor((left + right) / 2)
  //     let midVal = arr[midIndex]
  //     if(midVal < target){
  //         return binarySearch(arr, midVal + 1, right, target)
  //     }else if(midVal > target){
  //         return binarySearch(arr, left, midVal - 1, target )
  //     }else{
  //         return midVal
  //     }
  // }
  // let mid = binarySearch(arr, 0, arr.length-1, target)
  // return mid === target

  // 🐦直接在二维数组上采用二分查找
  const [m, n] = [matrix.length, matrix[0]?.length];
  if (!m) return false;
  let [row, col] = [m - 1, 0];
  while (row >= 0 && col <= n - 1) {
    if (matrix[row][col] > target) row--;
    else if (matrix[row][col] < target) col++;
    else return true;
  }
  return false;
};
```

🐦 答案

```js
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var findNumberIn2DArray = function (matrix, target) {
  // 暴力解法
  // for(let i=0; i<matrix.length; i++){
  //     for(let j=0; j<matrix[i].length; j++){
  //         if(matrix[i][j] === target) return true
  //     }
  // }
  // return false

  // 双指针
  /**
    思路：从左下角开始，小就向右移动，大就向上移动
     */
  const [m, n] = [matrix.length, matrix[0]?.length];
  if (!m) return false;
  let [row, col] = [m - 1, 0];
  while (row >= 0 && col <= n - 1) {
    if (matrix[row][col] === target) return true;
    else if (matrix[row][col] > target) row--;
    else col++;
  }
  return false;
};
```

**剑指 Offer 11. 旋转数组的最小数字**
将数组开始的 几个元素 进行了一次旋转 找最小值

```js
var minArray = function (numbers) {
  // 借用Api
  // numbers.sort((a,b) => a-b)
  // return numbers[0]

  // 二分查找
  /**
    思路：计算mid
    1.如果mid>right，则最小值在右侧，left=mid+1
    2.如果mid<right，则最小值在左侧或者mid就是最小值 right = mid
    3.如果mid=right，此时左右不确定，从最右边减1继续计算。right--;
     */
  let [left, right] = [0, numbers.length - 1];
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    if (numbers[mid] > numbers[right]) left = mid + 1; // 最小值在右侧
    else if (numbers[mid] < numbers[left]) right = mid;
    else right--;
  }
  return numbers[left];
};
```

**剑指 Offer 53 - I. 在排序数组中查找数字 I**

```js
var search = function (nums, target) {
  // 直接for循环
  let count = 0;
  for (let ele of nums) {
    if (target === ele) count++;
  }
  return count;
};
```

- 二分查找

```js
var search = function (nums, target) {
  // 二分法：优化---有点意思
  // 要看清给定的条件，这里已经说明是排序后的数组，所以如果有多个target，它在数组中是连续的
  /**
    思路：
    1.首先，二分查找，找到等于target的中间值
    2.然后，从中间值开始向两侧扩散
    3.标记最左侧和最右侧的位置，然后进行计算
     */
  let [left, right, flag] = [0, nums.length - 1, null];
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    let midNum = nums[mid];
    if (midNum > target) {
      right = mid - 1;
    } else if (midNum < target) {
      left = mid + 1;
    } else {
      // 找到一个就标记并退出循环
      flag = mid;
      break;
    }
  }
  // 当退出循环，flag仍为空则无数组中未出现target---注意这里不能写成(!flage)因为0也会转成false
  if (flag === null) return 0;
  // 从flag向两侧扩散
  left = right = flag;
  while (nums[left - 1] === target) left--;
  while (nums[right + 1] === target) right++;
  return right - left + 1;
};
```

**剑指 Offer 53 - II. 0 ～ n-1 中缺失的数字**
🦈 直接 for 循环,但是要排除两个特殊情况,一是第一个值不为 0,二是最后一个值缺失

```js
var missingNumber = function (nums) {
  // 直接for循环:排除索引0处不为0的情况和最后一个值确实的情况
  if (nums[0] === 1) return 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== i) return i;
  }
  return nums.length;
};
```

采用二分查找，根据中间值判断缺失数字是在左边还是右边
有序数组 ——> 二分查找

- nums[mid] === mid：左半边完整，缩小范围，开始找右半边
- nums[mid] !== mid：左半边不完整，缩小范围，在左半边找

```js
var missingNumber = function (nums) {
  // 二分查找
  // 有意思,通过判断中间值就知道左边有没有问题
  let [left, right] = [0, nums.length - 1];
  while (left <= right) {
    let mid = (left + right) >> 1;
    if (nums[mid] === mid) {
      //左边没有问题
      left = mid + 1;
    } else {
      //左边有问题
      right = mid - 1;
    }
  }
  return left;
};
```

## 双指针

**剑指 Offer 05. 替换空格**
思路：

1. 统计空格数量
2. 更新数组长度
3. 定义双指针，l 指向原数组， r 指向新数组
4. 遇到' '右指针一次赋值% 2 0，非空则把左指针的值赋值给有指针

```js
var replaceSpace = function (s) {
  // 将字符串转成数组
  // 快慢双指针从后往前遍历；相当于两个指针指向了两个数组
  const arr = s.split("");
  const len = arr.length;
  let count = 0;
  for (let str of s) {
    if (str === " ") count++;
  }
  arr.length += 2 * count;
  // 定义双指针
  let [l, r] = [len - 1, arr.length - 1];
  while (l >= 0) {
    if (arr[l] !== " ") {
      arr[r] = arr[l];
    } else {
      arr[r] = "0";
      arr[r - 1] = "2";
      arr[r - 2] = "%";
      r -= 2;
    }
    // 处理完一个字符都要左移
    l--;
    r--;
  }
  return arr.join("");
};
```

**剑指 Offer 21. 调整数组顺序使奇数位于偶数前面**

```js
var exchange = function (nums) {
  // 指定左右指针
  // 左指针查找到偶数停止，右指针查找到奇数停止
  // 左右指针交换
  let [left, right] = [0, nums.length - 1];
  while (left < right) {
    while (left < right && nums[left] & 1) left++;
    while (left < right && !(nums[right] & 1)) right--;
    [nums[left], nums[right]] = [nums[right], nums[left]];
  }
  return nums;
};
```

**剑指 Offer 22. 链表中倒数第 k 个节点**

```js
var getKthFromEnd = function (head, k) {
  // 快慢双指针
  // 思路：快指针先走k步，然后快慢指针一起走
  // 创建虚拟头节点
  const newNode = new ListNode(0);
  // 虚拟头节点指向头节点
  newNode.next = head;
  let slow = (fast = newNode);
  for (let i = 0; i < k; i++) {
    fast = fast.next;
  }
  while (fast) {
    fast = fast.next;
    slow = slow.next;
  }
  return slow;
};
```

**剑指 Offer 25. 合并两个排序的链表**
思路：

1. 创建虚拟头节点，并定义一个指针指向其头部
2. 创建 p1，p2 两个指针，指向两链表头部，一起遍历
3. 条件判断，p1 和 p2 哪个对应的值小，哪个就连接到答案链表

```js
var mergeTwoLists = function (l1, l2) {
  // 合并链表，向一个链表中加入另一个链表，保持顺序不变
  const newNode = new ListNode(0);
  let p = newNode;
  let [p1, p2] = [l1, l2];
  while (p1 && p2) {
    if (p1.val < p2.val) {
      p.next = p1;
      p1 = p1.next;
    } else {
      p.next = p2;
      p2 = p2.next;
    }
    p = p.next;
  }
  // 最后，跳出循环是p1 p2有一个为null，其中一个链表的一个节点还未添加到结果
  p.next = p1 ? p1 : p2;
  return newNode.next;
};
```

**剑指 Offer 57. 和为 s 的两个数字**
**剑指 Offer 57 - II. 和为 s 的连续正数序列**

- 滑动窗口思路，窗口初始化为[1, 2]，初始 sum 为 3
- 因为输出的序列至少有 2 个数，所以若窗口第一个数大于 target/2 时，就不再继续了
- 若 sum 太小，向窗口添加下一个数，更新 sum
- 若 sum 太大，弹出窗口第一个数，更新 sum
- 若 sum===target，则将窗口的数放入 res，随后弹出第一个数，继续滑动

```js
var findContinuousSequence = function (target) {
  // 滑动窗口（好题）
  const res = [];
  const window = [1, 2];
  let sum = 3; // 求和用于和target比较
  while (window[0] <= target >> 1) {
    if (sum < target) {
      // 新增值
      const num = window.at(-1) + 1;
      sum += num;
      window.push(num);
    } else if (sum > target) {
      sum -= window.shift();
    } else {
      res.push([...window]);
      sum -= window.shift();
    }
  }
  return res;
};
```

## Map()集合

**剑指 Offer 50. 第一个只出现一次的字符**

```js
var firstUniqChar = function (s) {
  // 借用indexOf()方法，查找元素第一次出现的索引值，没有则返回-1
  for (let i = 0; i < s.length; i++) {
    // 对遍历到元素，查找第一次出现时的索引值
    let firstInd = s.indexOf(s[i]);
    // 从查找到的第一个位置后面再次查找
    let sedInd = s.indexOf(s[i], firstInd + 1);
    // 如果后面都没有，则该值就是所要的结果
    if (sedInd === -1) return s[i];
  }
  return " ";
};
```

Map 集合

```js
var firstUniqChar = function (s) {
  // 思路：遍历字符串，记录字符出现的次数
  const map = new Map();
  let res = " ";
  for (let str of [...s]) {
    map.set(str, (map.get(str) || 0) + 1);
  }
  // 再次遍历把第一个出现次数为 1 的输出
  for (let str of s) {
    if (map.get(str) === 1) {
      res = str;
      break;
    }
  }
  return res;
};
```

**剑指 Offer 56 - II. 数组中数字出现的次数 II**

```js
var singleNumber = function (nums) {
  // 50T是统计的次数  这里统计是哪个数字
  // 方法一：indexOf
  // let res
  // for(let num of nums){
  //     let firstIndex = nums.indexOf(num)
  //     let secondIndex = nums.indexOf(num, firstIndex+1)
  //     if(secondIndex === -1) res = num
  // }
  // return res

  // 方法二：Map集合
  const map = new Map();
  let res;
  for (let num of nums) {
    map.set(num, (map.get(num) || 0) + 1);
  }
  for (let num of nums) {
    if (map.get(num) === 1) {
      res = num;
      break;
    }
  }
  return res;
};
```

## 链表

**剑指 Offer 06. 从尾到头打印链表**

```js
var reversePrint = function (head) {
  // 方法一：转换成数组
  // const arr = []
  // while(head){
  //     arr.push(head.val)
  //     head = head.next
  // }
  // return arr.reverse()
  // 方法二：反转链表
  let [cur, pre] = [head, null];
  while (cur !== null) {
    let temp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  // 对反转后的链表进行遍历
  const res = [];
  while (pre) {
    res.push(pre.val);
    pre = pre.next;
  }
  return res;
};
```

**剑指 Offer 18. 删除链表的节点**

```js
var deleteNode = function (head, val) {
  // 设置虚拟头节点，易于遍历
  let newNode = new ListNode(0);
  newNode.next = head;
  let curNode = newNode;
  while (curNode && curNode.next) {
    if (curNode.next.val === val) {
      curNode.next = curNode.next.next;
    } else {
      curNode = curNode.next;
    }
  }
  return newNode.next;
};
```

**剑指 Offer 24. 反转链表**

```js
var reverseList = function (head) {
  // 反转链表
  let [cur, pre] = [head, null];
  while (cur) {
    // 反转处理
    let temp = cur.next;
    cur.next = pre;
    // 理解为更新节点
    pre = cur;
    cur = temp;
  }
  return pre;
};
```

**剑指 Offer 35. 复杂链表的复制**
思路：

- 第一次遍历，复制节点值，key 和 val 都为链表的值
- 第二次遍历，复制节点关系，包含 next 指针和 random 指针

```js
var copyRandomList = function (head) {
  // map映射
  const map = new Map();
  // 第一次遍历
  let curNode = head;
  while (curNode) {
    // ???这里为什么加入的是new Node(curNode.val)？？？新节点
    map.set(curNode, new Node(curNode.val));
    curNode = curNode.next;
  }
  // 第二次遍历，复制指针关系
  curNode = head;
  while (curNode) {
    map.get(curNode).next = map.get(curNode.next) || null; // next指针
    map.get(curNode).random = map.get(curNode.random) || null; // random指针
    curNode = curNode.next;
  }
  return map.get(head);
};
```

**剑指 Offer 36. 二叉搜索树与双向链表**

```js
var treeToDoublyList = function (root) {
  // 排序的循环双向链表:第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
  // 不熟
  // 递归中序遍历
  const dfs = (cur) => {
    if (!cur) return;
    dfs(cur.left);
    if (!pre) {
      head = cur;
    } else {
      // pre有值，更新指针，双向连接
      pre.right = cur;
      cur.left = pre;
    }
    pre = cur;
    dfs(cur.right);
  };

  let pre, head;
  if (!root) return;
  dfs(root);
  // 首尾相连---最后跳出循环时，pre为最后一个节点为最右边的
  head.left = pre;
  pre.right = head;
  return head;
};
```

**剑指 Offer 52. 两个链表的第一个公共节点**

```js
var getIntersectionNode = function (headA, headB) {
  /**
    思路：两个链表互相遍历  (a+c) + b = (b+c) + a   两链表肯定会相交
    - 若
     */
  let [nodeA, nodeB] = [headA, headB];
  while (nodeA !== nodeB) {
    nodeA = nodeA === null ? headB : nodeA.next;
    nodeB = nodeB === null ? headA : nodeB.next;
  }
  return nodeA;
};
```

## 递归

### 构造二叉树

已知结论：

1. 中：根节点左右为左右子树
2. 后：最后一个元素为树的根节点
3. 前：第一个元素为树的根节点
   代码随想录：
   第一步：如果数组大小为零的话，说明是空节点了。
   第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
   第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
   第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
   第五步：切割后序数组，切成后序左数组和后序右数组
   第六步：递归处理左区间和右区间

🦈：
①. 指针交错或数组大小为空，返回 null
②. 获取后序遍历数组的最后一个元素作为二叉树的根节点
③. 确定根节点在中序遍历中的索引位置
④. 根据索引位置分割左右子树，计算左子树的长度（用于求后序中左右子树）
递归创建左右子树
**106. 从中序与后序遍历序列构造二叉树**

```js
var buildTree = function (inorder, postorder) {
  // 递归     左闭右闭
  /**
  思路分析：
  1.根据后序遍历数组最后一个元素获取根节点
  2.确定根节点元素在中序遍历数组中的位置
  3.确定左子树长度-->用来分隔后序遍历的左右子树
   */
  //  将中序遍历索引值保存-->更好的索引根节点元素在中序遍历数组中的位置
  const map = {};
  for (let i = 0; i < inorder.length; i++) {
    map[inorder[i]] = i;
  }
  // 定义递归函数
  const createTree = (iStart, iEnd, pStart, pEnd) => {
    // 确定终止条件
    if (pStart > pEnd || iStart > iEnd) return null;
    const rootVal = postorder[pEnd]; //获取根节点元素
    const minIndex = map[rootVal]; //获取根节点元素在中序遍历的索引值
    const leftNodeLength = minIndex - iStart; //获取左子树长度

    // 创建节点
    const root = new TreeNode(rootVal);
    // 递归
    root.left = createTree(
      iStart,
      minIndex - 1,
      pStart,
      pStart + leftNodeLength - 1
    );
    root.right = createTree(
      minIndex + 1,
      iEnd,
      pStart + leftNodeLength,
      pEnd - 1
    ); //递归构建右子树  不包含最后一个节点(根元素)
    return root;
  };
  return createTree(0, inorder.length - 1, 0, postorder.length - 1);
};
```

**剑指 Offer 07. 重建二叉树**

```js
var buildTree = function (preorder, inorder) {
  // 根据已知条件，确定根节点和左右子树，然后再递归确定左右子树
  // 建立映射
  const map = {};
  for (let i = 0; i < inorder.length; i++) {
    map[inorder[i]] = i;
  }
  // 递归
  const createTree = (preStart, preEnd, iStart, iEnd) => {
    // 确定终止条件
    if (preStart > preEnd || iStart > iEnd) return null;
    const rootVal = preorder[preStart]; // 确定根节点
    const rootIndex = map[rootVal]; // 确定根节点在中序遍历中的位置（索引值）
    const leftNodeLength = rootIndex - iStart; // 确定左子树长度

    // 创建节点
    const root = new TreeNode(rootVal);
    root.left = createTree(
      preStart + 1,
      preStart + leftNodeLength,
      iStart,
      rootIndex - 1
    );
    root.right = createTree(
      preStart + leftNodeLength + 1,
      preEnd,
      rootIndex + 1,
      iEnd
    );
    return root;
  };
  return createTree(0, preorder.length - 1, 0, inorder.length - 1);
};
```

**剑指 Offer 16. 数值的整数次方**
思路：

- 递归出口：n 为 0，返回 1
- 若 n 小于 0，特殊处理
- 若 n 为奇数，算 myPow(x, n - 1)，转化为偶数
- 若 n 为偶数，算 myPow(x \* x, n / 2)

```js
const myPow = (x, n) => {
  // 递归出口
  if (n === 0) return 1;
  // n小于0，特殊情况
  if (n < 0) return 1 / myPow(x, -n);
  // n奇数
  if (n & 1) return x * myPow(x, n - 1);
  // n偶数
  return myPow(x * x, n / 2);
};
```

**剑指 Offer 26. 树的子结构**
思路：

- A 空或 B 空，返回 false
- 递归判断 A 当前节点、A 左子树、A 右子树任意一个与 B 相同，就返回 true

```js
// 该递归函数是用来判断A当前节点和B是否相同
const dfs = (A, B) => {
  // 递归出口
  if (!B) return true;
  // A空，B不为空，false
  if (!A) return false;
  return A.val === B.val && dfs(A.left, B.left) && dfs(A.right, B.right);
};

const isSubStructure = (A, B) => {
  // 递归出口，A空或B空，false
  if (!A || !B) return false;
  // 递归判断A当前节点、A左子树、A右子树任意一个与B相同，就返回true
  return dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
};
```

**剑指 Offer 27. 二叉树的镜像**

```js
var mirrorTree = function (root) {
  // 根节点不变，交换左右子树
  // BFS
  // 🦈层序遍历，遍历一层后反转加入数组
  // const res = []
  // if(!root) return res
  // const queueNode = [root]
  // while(queueNode.length){
  //     // 保存一层节点
  //     const levelNode = []
  //     const len = queueNode.length
  //     for(let i=1; i<=len; i++){
  //         let node = queueNode.shift()
  //         levelNode.unshift(node.val)
  //         node.left && queueNode.push(node.left)
  //         node.right && queueNode.push(node.right)
  //     }
  //     res.push(levelNode)
  // }
  // return res.flat()

  // 🐦
  // 方法二⭐⭐
  // 递归出口
  if (!root) return null;
  // 交换当前左右节点
  [root.left, root.right] = [root.right, root.left];
  // 递归交换左子树的左右节点
  mirrorTree(root.left);
  // 递归交换右子树的左右节点
  mirrorTree(root.right);
  // 返回当前节点给上一级
  return root;

  // 方法三⭐⭐⭐
  if (!root) return null;

  const node = new TreeNode(root.val);

  node.left = mirrorTree(root.right);
  node.right = mirrorTree(root.left);

  return node;
};
```

**剑指 Offer 28. 对称的二叉树**
DFS
判断一个二叉树是否对称，只需判断二叉树的两个子树是否镜像即可。 镜像的条件：

1. 节点值相等
2. node1 的左子树和 node2 的右子树是镜像
3. node1 的右子树和 node2 的左子树是镜像

```js
const isSymmetric = (root) => {
  if (!root) return true;
  // 判断两个二叉树是否镜像
  const check = (node1, node2) => {
    // 两个空树，true
    if (!node1 && !node2) return true;
    // 只有一个空树，false
    if (!node1 || !node2) return false;
    // 镜像的条件：
    // 1. 节点值相等
    // 2. node1的左子树和node2的右子树是镜像
    // 3. node1的右子树和node2的左子树是镜像
    return (
      node1.val === node2.val &&
      check(node1.left, node2.right) &&
      check(node1.right, node2.left)
    );
  };
  // 判断树的两个子树是否镜像即可
  return check(root.left, root.right);
};
```

BFS

```js
const isSymmetric = (root) => {
  if (!root) return true;
  // 根节点的左右节点入队
  const queue = [root.left, root.right];
  while (queue.length) {
    // 当前队列的长度
    const len = queue.length;
    // 每次对比两个节点，所以i=i+2
    for (let i = 0; i < len; i += 2) {
      // 两个节点出队
      const left = queue.shift();
      const right = queue.shift();
      // 有一个为空，另一个不为空，直接返回false
      if ((left && !right) || (!left && right)) return false;
      // 两节点都不为空
      if (left && right) {
        // 值不相等，返回false
        if (left.val !== right.val) return false;
        // 将两个节点的左右节点，按照对应关系入队
        queue.push(left.left, right.right, left.right, right.left);
      }
    }
  }
  // 遍历结束返回true
  return true;
};
```

**剑指 Offer 33. 二叉搜索树的后序遍历序列**
给定一个数组，判断是不是后序遍历数组
🐦
此题中输入的数组的任意两个数字都互不相同，所以此题的二叉搜索树的左子树节点都小于根节点，右子树节点都大于根节点。

- 后序遍历，最后一个是根节点
- 找到第一个大于根节点的位置 i
- 从 i 开始，判断 i 右边到根节点之间的元素，是否都大于根节点值，若否，直接返回 false；若是，递归判断左右子树

```js
const verifyPostorder = (postorder) => {
  const len = postorder.length;
  // 递归出口
  if (len <= 1) return true;
  // 后序遍历，最后一个是根节点
  const root = postorder[len - 1];
  // 找到第一个大于根节点的位置i
  let i = 0;
  while (postorder[i] < root) i++;
  // 从i开始，判断i右边到根节点之间的元素，也就是右子树是否都大于根节点值
  const res = postorder.slice(i, len - 1).every((x) => x > root);
  // 若否，直接返回false
  // 若是，递归判断左右子树
  return res
    ? verifyPostorder(postorder.slice(0, i)) &&
        verifyPostorder(postorder.slice(i, len - 1))
    : false;
};
```

**剑指 Offer 38. 字符串的排列**
回溯[参考](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/solution/javascriptban-jie-ti-si-lu-by-ityou-o-obh8/)
在题目 47.全排列 II 的基础上进行了一点点改动

```js
var permutation = function (s) {
  // 回溯:想象成树，很好理解
  // 注意：⭐有 aab 重复字符串，所以采用Set
  const path = [];
  const res = new Set();
  const backtracking = (s, uset) => {
    if (path.length === s.length) {
      res.add([...path].join(""));
      return;
    }
    for (let i = 0; i < s.length; i++) {
      if (uset[i]) continue;
      uset[i] = true;
      path.push(s[i]);
      backtracking(s, uset);
      path.pop();
      uset[i] = false;
    }
  };
  backtracking(s, []);
  return Array.from(res); // 将Set集合（类数组）转成数组
};
```

**剑指 Offer 55 - II. 平衡二叉树**
在求二叉树的深度函数的代码上稍作修改即可：

若左子树返回-1，或右子树返回-1，或者高度差的绝对值大于 1，就返回-1
否则就返回当前节点数的深度

```js
const isBalanced = (root) => {
  // 如果返回-1，则该节点不平衡
  const check = (node) => {
    if (!node) return 0;
    const left = check(node.left);
    const right = check(node.right);
    if (left === -1 || right === -1 || Math.abs(left - right) > 1) {
      return -1;
    }
    return Math.max(left, right) + 1; // ⭐？？？？
  };
  // 若等于-1，则不是平衡二叉树
  return check(root) !== -1;
};
```

**剑指 Offer 64. 求 1+2+…+n**

```js
var sumNums = function (n) {
  return n && sumNums(n - 1) + n;
};
```

**剑指 Offer 68 - II. 二叉树的最近公共祖先**

🐦
思路：

- 若根节点等于 p 或 q，那么 root 是最近公共祖先
- 向左右子树寻找节点相同的点
- 若左右各找到一个，那么当前根节点就是最近公共祖先
- 若只有左边找到，那么最近公共祖先在左边（pq 节点都在左边）
- 若只有右边找到，那么最近公共祖先在左边（都在右边）

```js
const lowestCommonAncestor = (root, p, q) => {
  if (!root) return null;
  // 根节点等于p或q，那么root是最近公共祖先
  if (root === p || root === q) return root;
  // 向左子树寻找节点相同的点
  const left = lowestCommonAncestor(root.left, p, q);
  // 向右子树寻找节点相同的点
  const right = lowestCommonAncestor(root.right, p, q);
  // 若左右各找到一个，那么当前根节点就是最近公共祖先
  if (left && right) return root;
  // 只有左边找到，那么最近公共祖先在左边
  if (left) return left;
  // 只有右边找到，那么最近公共祖先在左边
  if (right) return right;
};
```

## 栈、队列

**剑指 Offer 09. 用两个栈实现队列**

```js
// 创建两个栈
var CQueue = function () {
  this.inStack = [];
  this.outStack = [];
};

/**
 * @param {number} value
 * @return {void}
 */
// 添加到队列尾部,直接压入到输入栈就可以
CQueue.prototype.appendTail = function (value) {
  this.inStack.push(value);
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function () {
  // 如果两个栈都为空返回-1
  if (!this.inStack.length && !this.outStack.length) return -1;
  // 如果输出栈为空，则将输入栈的元素弹出，压入到输出栈中
  if (!this.outStack.length) {
    while (this.inStack.length) {
      this.outStack.push(this.inStack.pop());
    }
  }
  // 输出栈不为空，直接弹出
  return this.outStack.pop();
};
```

**剑指 Offer 30. 包含 min 函数的栈**

```js
//  ...这里说的是栈不是队列了   脑残吗？
var MinStack = function () {
  this.stack = [];
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function (x) {
  this.stack.push({
    val: x,
    min: this.stack.length ? Math.min(x, this.min()) : x, // 栈为空直接加入,不为空取最小值
  });
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function () {
  return this.stack.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function () {
  return this.stack.at(-1).val;
};

/**
 * @return {number}
 */
MinStack.prototype.min = function () {
  return this.stack.at(-1).min;
};
```

**剑指 Offer 31. 栈的压入、弹出序列**
🐦
⭐ 手写模拟一下就明白

```js
var validateStackSequences = function (pushed, popped) {
  // 只有第一个元素可以比后一个元素小，其余元素都大？×
  // 自己比较难想出来
  /**
    思路：
    创建一个栈，当弹出序列popped与遍历到的压入序列pushed不匹配时，压栈处理，否则弹栈，最后判断栈是否为空
     */
  const stack = [];
  let index = 0;
  const len = pushed.length;
  for (let i = 0; i < len; i++) {
    stack.push(pushed[i]);
    while (stack.length && popped[index] === stack.at(-1)) {
      stack.pop();
      index++;
    }
  }
  return !stack.length;
};
```

## 7、动态规划

**剑指 Offer 10- I. 斐波那契数列**

```js
var fib = function (n) {
  // dp[i] 表示第 i 项，斐波那契数为dp[i]
  if (n <= 1) return n;
  const dp = [0, 1];
  for (let i = 2; i <= n; i++) {
    dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
  }
  return dp[n];
};
```

**剑指 Offer 10- II. 青蛙跳台阶问题**
爬楼梯举例：
爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。
那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。
所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。

🐦 思路
第 n 阶的数量由前两阶的数量相加而来，故用动态规划。

dp[i]表示第 i 阶有 dp[i]种方法
递推公式：dp[i] = dp[i - 1] + dp[i - 2]
dp 数组初始化：dp = [null, 1, 2]，dp[0]没有意义，从 i=3 开始循环
遍历顺序：从前往后

```js
var numWays = function (n) {
  // 比较重要的点：确定dp[i]的含义和递推公式
  // dp[i] 表示跳到i阶台阶时，有dp[i]种跳法
  // 递推公式：dp[i] += dp[i-1] + dp[i-2]
  if (n === 0) return 1;
  const dp = [null, 1, 2];
  for (let i = 3; i <= n; i++) {
    dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
  }
  return dp[n];
};
```

**剑指 Offer 14- I. 剪绳子**
两层遍历：第一层表示绳子的长度 第二层用来表示第一段减去的长度。要想求最大值，有两种情况：
剪绳子：剪绳子的话乘积就是 j _ dp[i - j] 减去第一段的长度 _ 剩下长度的最大值
剪第一段，第二段不剪，直接 j _ (i - j) 当前的长度 _ 剩下的长度
不剪 dp[i]

🐦[参考](https://github.com/lzxjack/coding-interviews/blob/master/problems/14-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90.md)

```js
const cuttingRope = (n) => {
  // dp[i] 剪长度为 i 的绳子，得到的最大乘积为dp[i]
  /**
    要遍历两次：第一层表示绳子的长度，第二层表示第一段减去的长度
    剪绳子的两种情况：
    1. 剪一段：当前长度 * 剩下长度 j * (i - j)
    2. 剪多段就：第一段长度 * 剩下长度的最大值 j * dp[i-j]
     */
  const dp = [null, null, 1];
  for (let i = 3; i <= n; i++) {
    // 当前dp[i]初始化为0
    dp[i] = 0;
    for (let j = 1; j <= i - 1; j++) {
      // 因为j在遍历的过程中，会算出很多dp[i]，取最大的
      // (i - j) * j表示拆分成2个数
      // dp[i - j] * j表示拆分成2个及以上的数
      dp[i] = Math.max(dp[i], (i - j) * j, dp[i - j] * j);
    }
  }
  return dp[n];
};
```

**剑指 Offer 46. 把数字翻译成字符串**
🐦 思路
使用动态规划来解题：

1. dp[i]含义：0~i-1 范围的数字，能翻译的个数
2. 递推公式：i-1 和 i-2 若能被翻译，则 dp[i] = dp[i - 1] + dp[i - 2]；否则，dp[i] = dp[i - 1]
3. dp 数组初始化：dp[0]代表空字符串，当然只有 1 种。dp[1]代表 str[0]，单个字符，当然也只有 1 种，所以 dp = [1, 1]
4. 当前 dp[i]依赖于之前项，所以从前向后遍历

```js
var translateNum = function (num) {
  // 求种数
  const str = `${num}`;
  const len = str.length;
  const dp = [1, 1];
  for (let i = 2; i < len + 1; i++) {
    const preNum = parseInt(str[i - 2] + str[i - 1]); // 将两个字符串拼接然后转成十进制数(⭐拼接顺序别搞颠倒了)
    // 判断:如果是符合条件的两位数则 种数有两种情况的来
    if (preNum >= 10 && preNum <= 25) {
      dp[i] = dp[i - 1] + dp[i - 2];
    } else {
      dp[i] = dp[i - 1];
    }
  }
  return dp[len];
};
```

**剑指 Offer 47. 礼物的最大价值**
与 62.不同路径类似

```js
var maxValue = function (grid) {
  // dp[i][j]表示在棋盘(i, j)位置所得到的礼物价值最大和
  const m = grid.length;
  const n = grid[0].length;
  const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));
  dp[0][0] = grid[0][0];
  for (let i = 1; i < m; i++) {
    dp[i][0] = dp[i - 1][0] + grid[i][0];
  }
  for (let j = 1; j < n; j++) {
    dp[0][j] = dp[0][j - 1] + grid[0][j];
  }
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }
  return dp[m - 1][n - 1];
};
```

🐦

使用动态规划来解题：

1. dp[i][j]含义：
   从(0,0)移动到(i,j)，可以拿的最大价值为 dp[i][j]
2. dp 数组初始化：
   (0,0)位置肯定还是原来的值。
   第一列(i,0)：只能从上边走到该位置，所以 dp[i][0] = dp[i - 1][0] + grid[i][0]
   第一行(0,j)：只能从左边走到该位置，所以 dp[0][j] = dp[0][j - 1] + grid[0][j]
3. 递推公式：
   对于除了第一行、第一列的 dp[i][j]，可以有两个地方走到这里，上边和左边，取他们的最大值，再加上当前位置的价值
   dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
4. 遍历顺序：
   当前值依赖于上边的值、左边的值，所以从左往右、从上到下，一行一行遍历

```js
const maxValue = (grid) => {
  // 行、列
  const [m, n] = [grid.length, grid[0].length];
  // 创建行m列n的二维数组
  const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));
  // (0,0)位置初始化
  dp[0][0] = grid[0][0];
  // 第一列初始化
  for (let i = 1; i < m; i++) {
    dp[i][0] = dp[i - 1][0] + grid[i][0];
  }
  // 第一行初始化
  for (let j = 1; j < n; j++) {
    dp[0][j] = dp[0][j - 1] + grid[0][j];
  }
  // 遍历，完善dp数组
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
    }
  }
  return dp[m - 1][n - 1];
};
```

**剑指 Offer 63. 股票的最大利润**
贪心

```js
var maxProfit = function (prices) {
  // 给定了限定条件，只买卖一次
  /**
    思路：
    1. 先定义最低价格和利润
    2. 遍历数组，更新最低价格和利润
    3. 返回利润
     */
  let minPrice = prices[0]; // 假设第一天为最低价格
  let maxProfile = 0;
  for (let i = 1; i < prices.length; i++) {
    minPrice = Math.min(minPrice, prices[i]);
    maxProfile = Math.max(maxProfile, prices[i] - minPrice);
  }
  return maxProfile;
};
```

动规
同 121. 买卖股票的最佳时机 题一样

```js
var maxProfit = function (prices) {
  // 给定了限定条件，只买卖一次
  // 🦈动规
  /**
    思路：每天 有持有和不持有股票 两种状态
    1. dp[i][0]表示第i天持有股票的利润
       dp[i][1]表示第i天不持有股票的利润
    2. 递推公式
    dp[i][0] = Math.max(dp[i-1][0], -prices[i])
    dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i])
     */
  if (prices.length <= 1) return 0;
  const dp = new Array(prices.length).fill(0).map(() => new Array(2).fill(0));
  dp[0][0] = -prices[0];
  dp[0][1] = 0;
  for (let i = 1; i < prices.length; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
  }
  return dp[prices.length - 1][1];
};
```

## 8、贪心

**剑指 Offer 14- II. 剪绳子 II**

⭐ 要取模，不能 dp

```js
var cuttingRope = function (n) {
  // 特殊情况处理
  const arr = [null, null, 1, 2, 4];
  if (n <= 4) return arr[n];
  const mod = 1000000007;
  let res = 1;
  while (n > 4) {
    // 不断-3
    res = (res * 3) % mod;
    n -= 3;
  }
  // 最后剩n等于4
  res *= n;
  return res % mod;
};
```

**剑指 Offer 42. 连续子数组的最大和**

```js
var maxSubArray = function (nums) {
  // 贪心
  // 思路：设置count用以求和，res用以存储结果，从前往后遍历，遍历到一个数就count+加上这个数，然后res取最大值，当求和<0,就重新计数
  let [count, res] = [0, -Infinity];
  for (let i = 0; i < nums.length; i++) {
    count += nums[i];
    res = Math.max(count, res);
    if (count < 0) count = 0;
  }
  return res;
};
```

**剑指 Offer 63. 股票的最大利润**
贪心

```js
var maxProfit = function (prices) {
  // 设定最低价格(假设第一天为最低价格)和最大利润
  // 然后从第2天开始遍历，
  let minPrice = prices[0];
  let maxProfile = 0;
  for (let i = 1; i < prices.length; i++) {
    minPrice = Math.min(minPrice, prices[i]); // 比较已确定的最低价格和当前天的价格取最小
    maxProfile = Math.max(maxProfile, prices[i] - minPrice); // 比较已确定的最大利润和当前价格减去最低价格，取最大值作为利润
  }
  return maxProfile;
};
```

动规

```js
var maxProfit = function (prices) {
  // 🦈动规
  // 持有、不持有两种状态，持有时，利润为负，取最大值（即确定买入的最低价格），
  // 不持有时，用当天的价格+（-前一天持有的价格）
  if (prices.length <= 1) return 0;
  const dp = new Array(prices.length).fill(0).map(() => new Array(2).fill(0));
  dp[0][0] = -prices[0]; // 持有， 利润为负
  dp[0][1] = 0; // 不持有（卖出）
  for (let i = 1; i < prices.length; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); // 持有
    dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
  }
  return dp[prices.length - 1][1];
};
```

## 9、回溯算法

**剑指 Offer 34. 二叉树中和为某一值的路径**
思路：
1. path记录路径、res存放结果
2. 每访问到一个节点就加入路径并求和，当到达叶子节点，并且sum === target，就加入结果数组
3. 不满足条件就继续遍历树，最后仍不满足就回溯处理
```js
var pathSum = function(root, target) {
    // 回溯：path记录路径，res存储结果
    const path = [];
    const res = [];
    const backtracking = (root, target, sum) => {
        // 加入路径
        path.push(root.val)
        // 求和
        sum += root.val;
        // 满足条件：到达叶子节点，并且===目标和
        if(!root.left && !root.right && sum === target){
            res.push([...path]);
        }
        root.left && backtracking(root.left, target, sum)
        root.right && backtracking(root.right, target, sum)
        // 回溯
        path.pop()
    }
    root && backtracking(root, target, 0)
    return res;
};
```
## 10、DFS 深度优先遍历


