# 链表

## 基础知识

- 插入操作
  向链表中插入一 个节点，需要修改它前面的节点（前驱 ），使其 指向新加入的节点，而新加入的节点则指向原来前 驱指向的节点。
- 删除操作
  将待删除元素的 前驱节点指向待删除元素的后继节点，同时将待删 除元素指向 null ，元素就删除成功了。
- 设计基于对象的链表

- 自定义单向链表
**注意：**
双向链表：与单向相比多了个前驱节点previous
循环链表：与单向相比，使最后一个节点指向头节点
```js
// 自定义链表
    /* 
    包含两个类，Node 类用来表示节 点，LinkedList 类提供了插入节点、删除节点、显 示列表元素的方法
    */
// Node类
function Node(element) {
  this.element = element; //保存节点上的数据
  this.next = null; // 保存指向下一个节点的链接;初始化为null，当有新元素插入时，指向新元素
}
// LList类：对链表的操作方法
function LList() {
  this.head = new Node("head");
  this.find = find; // 查找节点
  this.insert = insert;
  this.findPrevious = findPrevious;
  this.remove = remove;
  this.display = display;
}
// find方法，
function find(item) {
  let curNode = this.head;
  while (curNode.element !== item) {
    curNode = curNode.next;
  }
  return curNode;
}
// insert方法,插入节点，（这里是在一个已知节点后面插入元素）
function insert(newElement, item) {
  let newNode = new Node(newElement);
  let current = this.find(item);
  current.next = newNode;
  newNode.next = current.next.next;
}
// display显示链表元素---打印输出
function display() {
  // 当前节点不为null就打印输出
  let curNode = this.head;
  while (curNode.next !== null) {
    console.log(curNode.next.element);
    curNode = curNode.next;
  }
}
// remove删除节点:先找到待删除节点的前一节点，然后再对节点进行删除
function findPrevious(item) {
  // 判断下一个节点不是待删除元素，就找到了待删除元素的前一节点
  let curNode = this.head;
  while (curNode !== null && curNode.next.element !== item) {
    curNode = curNode.next;
  }
  return curNode;
}
function remove(item) {
  let prevNode = this.findPrevious(item);
  if (prevNode.next !== null) {
    prevNode.next = prevNode.next.next;
  }
}

// 测试代码
let cities = new LList();
// 插入元素
cities.insert("Beijing", "head");
cities.insert("Tianjin", "Beijing");
cities.insert("Yantai", "Tianjin");
cities.insert("Xian", "Yantai");
cities.display();
console.log("==========");
cities.remove("Xian");
cities.display();
```
- 其他方法
  - advance(n)
    在链表中向前移动n 个节点。
  - back(n)
    在双向链表中向后移动n 个节点。
  - show()
    只显示当前节点

## 题目

###

203.移除链表元素 
思路：设置虚拟头节点，指向head
遍链表，遇到val就删除（curNode.next = curNode.next.next）
```js
var removeElements = function(head, val) {
    // 创建虚拟头节点指向head
    const newNode = new ListNode(0)
    // 使头节点指向head
    newNode.next = head
    // 设置当前节点为虚拟头节点
    let curNode = newNode
    while(curNode && curNode.next){
        if(curNode.next.val === val){
            curNode.next = curNode.next.next
        }else{
            curNode = curNode.next
        }
    }
    return newNode.next
};
```
707.设计链表 

206.反转链表 
思路：
双指针：设置一个前驱节点，使链表重新指向，定义一个临时节点，边遍历链表边重新设置指向。
```js
var reverseList = function(head) {
    // 单链表反转链表---采用双指针方法（也不算是双指针，就是设置了一个前驱节点）
    let [cur, pre] = [head, null]
    while(cur !== null){
        // 保存当前节点的下一个节点
        const temp = cur.next
        // 让当前节点指向前驱节点
        cur.next = pre
        // 更新两个节点（更新双指针cur pre）
        pre = cur
        cur = temp
    }
    return pre
};
```
92.反转链表 II 
234.回文链表 
19.删除链表的倒数第 N 个节点
面试题 02.07. 链表相交 
142.环形链表 II
