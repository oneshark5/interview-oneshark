# 链表

## 基础知识

- 插入操作
  向链表中插入一 个节点，需要修改它前面的节点（前驱 ），使其 指向新加入的节点，而新加入的节点则指向原来前 驱指向的节点。
- 删除操作
  将待删除元素的 前驱节点指向待删除元素的后继节点，同时将待删 除元素指向 null ，元素就删除成功了。
- 设计基于对象的链表

- 自定义单向链表
**注意：**
双向链表：与单向相比多了个前驱节点previous
循环链表：与单向相比，使最后一个节点指向头节点
```js
// 自定义链表
    /* 
    包含两个类，Node 类用来表示节 点，LinkedList 类提供了插入节点、删除节点、显 示列表元素的方法
    */
// Node类
function Node(element) {
  this.element = element; //保存节点上的数据
  this.next = null; // 保存指向下一个节点的链接;初始化为null，当有新元素插入时，指向新元素
}
// LList类：对链表的操作方法
function LList() {
  this.head = new Node("head");
  this.find = find; // 查找节点
  this.insert = insert;
  this.findPrevious = findPrevious;
  this.remove = remove;
  this.display = display;
}
// find方法，
function find(item) {
  let curNode = this.head;
  while (curNode.element !== item) {
    curNode = curNode.next;
  }
  return curNode;
}
// insert方法,插入节点，（这里是在一个已知节点后面插入元素）
function insert(newElement, item) {
  let newNode = new Node(newElement);
  let current = this.find(item);
  current.next = newNode;
  newNode.next = current.next.next;
}
// display显示链表元素---打印输出
function display() {
  // 当前节点不为null就打印输出
  let curNode = this.head;
  while (curNode.next !== null) {
    console.log(curNode.next.element);
    curNode = curNode.next;
  }
}
// remove删除节点:先找到待删除节点的前一节点，然后再对节点进行删除
function findPrevious(item) {
  // 判断下一个节点不是待删除元素，就找到了待删除元素的前一节点
  let curNode = this.head;
  while (curNode !== null && curNode.next.element !== item) {
    curNode = curNode.next;
  }
  return curNode;
}
function remove(item) {
  let prevNode = this.findPrevious(item);
  if (prevNode.next !== null) {
    prevNode.next = prevNode.next.next;
  }
}

// 测试代码
let cities = new LList();
// 插入元素
cities.insert("Beijing", "head");
cities.insert("Tianjin", "Beijing");
cities.insert("Yantai", "Tianjin");
cities.insert("Xian", "Yantai");
cities.display();
console.log("==========");
cities.remove("Xian");
cities.display();
```
- 其他方法
  - advance(n)
    在链表中向前移动n 个节点。
  - back(n)
    在双向链表中向后移动n 个节点。
  - show()
    只显示当前节点

## 题目

### 203.移除链表元素 
思路：设置虚拟头节点，指向head
遍链表，遇到val就删除（curNode.next = curNode.next.next）
```js
var removeElements = function(head, val) {
    // 创建虚拟头节点指向head
    const newNode = new ListNode(0)
    // 使头节点指向head
    newNode.next = head
    // 设置当前节点为虚拟头节点
    let curNode = newNode
    while(curNode && curNode.next){
        if(curNode.next.val === val){
            curNode.next = curNode.next.next
        }else{
            curNode = curNode.next
        }
    }
    return newNode.next
};
```
### 707.设计链表 

### 206.反转链表 
思路：
双指针：设置一个前驱节点，使链表重新指向，定义一个临时节点，边遍历链表边重新设置指向。
```js
var reverseList = function(head) {
    // 单链表反转链表---采用双指针方法（也不算是双指针，就是设置了一个前驱节点）
    let [cur, pre] = [head, null]
    while(cur !== null){
        // 保存当前节点的下一个节点
        const temp = cur.next
        // 让当前节点指向前驱节点
        cur.next = pre
        // 更新两个节点（更新双指针cur pre）
        pre = cur
        cur = temp
    }
    return pre
};
```
### 92.反转链表 II 
思路：
- 先找待反转区域的left的前一节点标记为pre
- 标记当前节点cur
- 反转时：
  - 保存当前节点的下一节点next = cur.next
  - 使当前节点指向下一节点的下一个节点 cur.next = next.next
  - 然后改变当前节点的下一个节点的指向前一节点的下一个节点 next.next = pre.next
  - 最后修改前驱节点指向当前节点的下一节点 pre.next = next
```js
var reverseBetween = function(head, left, right) {
    // 部分链表反转
    // 思路：找到待反转区域，然后按照T206思路进行反转
    let newNode = new ListNode(-1)
    newNode.next = head
    let pre = newNode
    // 遍历找到待反转区域的left的前一个节点
    for(let i=0; i<left-1; i++){
        pre = pre.next
    }
    let cur = pre.next //待反转区域的left
    // 对待反转区域进行反转扁遍历
    for(let i=0; i<right-left; i++){
        // 两个节点反转操作
        next = cur.next //保存当前节点的下一个几点
        cur.next = next.next // 当前节点指向它下一个节点的下一个节点
        next.next = pre.next // 当前节点的下一节点指向前驱节点的下一节点
        pre.next = next
    }
    return newNode.next
};
```
### 234.回文链表 
方法一：前后双指针+数组
思路：先转换成数组再判断（设定前后两个指针）
```js
var isPalindrome = function(head) {
    // 回文链表判断
    /**
    思路：遍历链表，给定前后双指针，如果前后双指针指向元素不等则返回false
     */
    // 创建链表，加入到数组
    let arrVals = []
    while(head){
        arrVals.push(head.val)
        head = head.next
    }
    let [left, right] = [0, arrVals.length-1]
    while(left < right){
        if(arrVals[left] !== arrVals[right]) return false
        left++
        right--
    }
    return true
};
```
方法二：快慢双指针
思路：
    1.先确定中间位置，把链表分为两段
    2.把后半段反转
    3.判断两端是否相同
```js
var isPalindrome = function(head) {
    // 回文链表判断
    // ⭐方法二：快慢双指针
    // 检查特殊情况
    if(!head || !head.next) return true
    // 链表分两段
    let slow = fast = head
    let prev = null
    while(fast && fast.next){
        prev = slow
        slow = slow.next
        fast = fast.next.next
    }
    prev.next = null
    // 反转后半段
    let head2 = null // 设定第二段虚拟头节点
    while(slow){
        const temp = slow.next
        slow.next = head2
        head2 = slow
        slow = temp
    }
    // 比较两链表
    while(head && head2){
        if(head.val !== head2.val) return false
        head = head.next
        head2 = head2.next
    }
    return true
};
```

19.删除链表的倒数第 N 个节点
🦈对链表的掌握不熟练
思路：
1. 设置虚拟头节点，双指针指向头节点
2. 让fast先走n步，然后一起移动
3. 待fast移动到最后时，找到待删除节点
```js
var removeNthFromEnd = function(head, n) {
    // 方法一：删除链表的第head.length-n-1个节点---没做出来
    // 方法二：快慢双指针
    const newNode = new ListNode(0)
    newNode.next = head
    let fast = slow = newNode;
    for(let i=0; i<n; i++){
        fast = fast.next
    }
    // 采用pre指向待删除节点的前一个几点
    let pre = null
    while(fast){
        pre = slow
        slow = slow.next
        fast = fast.next
    }
    // 删除节点
    pre.next = slow.next
    return newNode.next
};
```

面试题 02.07. 链表相交 
142.环形链表 II





**参考：链表设计**
```js
//初始化
var MyLinkedList = function () {
  //节点有一个val和一个next代表该节点的值和下一节点
  this.Node = function (val) {
    this.val = val;
    this.next = null;
  };
  //此处没有设置虚拟头节点，大家可以自己试试，有虚拟头的话，后面遍历链表的话会简单的多。
  this.size = 0;
};

//获取操作
MyLinkedList.prototype.get = function (index) {
  //判断边界
  if (index < 0 || index > this.size - 1) {
    return -1;
  }
  //从头开始遍历,其他方法同理
  let node = this.head;
  //查找index
  for (let i = 0; i < index; i++) {
    node = node.next;
  }
  return node.val;
};

//头尾添加节点均调用了addAtindex的方法
MyLinkedList.prototype.addAtHead = function (val) {
  this.addAtIndex(0, val);
};

MyLinkedList.prototype.addAtTail = function (val) {
  this.addAtIndex(this.size, val);
};

//添加操作
MyLinkedList.prototype.addAtIndex = function (index, val) {
  let node = this.head;
  //判断小于等于0和链表长度为0的情况
  if (index <= 0 || this.size === 0) {
    this.head = new this.Node(val);
    this.head.next = node;
  } else {
    //当index > 0时
    for (let i = 0; i < index - 1 && i <= this.size; i++) {
      node = node.next;
    }
    //循环结束开始插入
    let temp = node.next;
    node.next = new this.Node(val);
    node.next.next = temp;
  }
  this.size++;
  return;
};

//删除操作
MyLinkedList.prototype.deleteAtIndex = function (index) {
  if (index < 0 || index > this.size - 1) {
    return -1;
  }

  let node = this.head;

  if (index === 0) {
    //对0单独判断
    this.head = this.head.next;
    //分为大于小于0两种情况
  } else {
    //查找index
    for (let i = 0; i < index - 1; i++) {
      node = node.next;
    }
    // a --> b --> c  a --> c
    let temp = node.next;
    node.next = temp.next;
    temp = null;
  }
  
  this.size--;
  return;
};

```