# 二叉树
## 知识点
## 题目
递归法
实现递归的三个步骤：
1. 确定参数和返回值
2. 确定终止条件
3. 确定单层递归逻辑
**144.二叉树的前序遍历**
```js
var preorderTraversal = function(root) {
    // 递归前序遍历
    const ans = []
    preTraversal(root, ans)
    return ans
};
// 定义前序遍历
const preTraversal = (cur, res) => {
    if(cur === null) return;
    res.push(cur.val)
    preTraversal(cur.left, res)
    preTraversal(cur.right, res)    
}
```
**145.二叉树的后序遍历**
```js
var postorderTraversal = function(root) {
    const ans = []
    postTraversal(root, ans)
    return ans
};
const postTraversal = (cur, res) => {
    if(cur === null) return
    postTraversal(cur.left, res)
    postTraversal(cur.right, res)
    res.push(cur.val)
    return res
}
```
**94.二叉树的中序遍历**
```js
var inorderTraversal = function(root) {
    const ans = []
    inTraversal(root, ans)
    return ans
};
const inTraversal = (cur, res) => {
    if(cur === null) return
    inTraversal(cur.left, res)
    res.push(cur.val)
    inTraversal(cur.right, res)
    return res
}
```

迭代法
**144.二叉树的前序遍历**
```js
var preorderTraversal = function(root) {
    // 迭代法:前序遍历，压栈顺寻  中右左
    const res = []
    if(!root) return res
    const stack = []
    stack.push(root)
    while(stack.length){
        let cur = stack.pop()
        res.push(cur.val)
        cur.right && stack.push(cur.right)
        cur.left && stack.push(cur.left)
    }
    return res
};
```
**94.二叉树的中序遍历**
```js
var inorderTraversal = function(root) {
    // 迭代法：中序遍历  左中右
    const res = []
    if(!root) return res
    const stack = []
    let cur = root
    while(cur || stack.length){
        if(cur){
            stack.push(cur)
            cur = cur.left
        }else{
            cur = stack.pop()
            res.push(cur.val)
            cur = cur.right
        }
    }
    return res
};
```
**145.二叉树的后序遍历**
```js
var postorderTraversal = function(root) {
    // 迭代法：后序遍历 左右中
    // 思路：在前序遍历的基础上去做，要么采用前序遍历然后反转数组，要么直接加入到结果数组头部
    const res = []
    if(!root) return res
    const stack = [root]
    while(stack.length){
        // 前序
        let cur = stack.pop()
        res.unshift(cur.val)
        cur.left && stack.push(cur.left)
        cur.right && stack.push(cur.right)
    }
    return res
};
```

**102.二叉树的层序遍历**
```js
var levelOrder = function(root) {
    // 双重队列
    const res = []
    if(!root){
        return res
    }
    // 模拟队列---取值时用shift()就可以
    const queueNode = []
    queueNode.push(root)
    while(queueNode.length){
        // 队列---保存一层节点
        const levelList = []
        // 这里一定要使用固定大小length，因为queueNode.length是不断变化的
        const length = queueNode.length
        for(let i=1; i<=length; i++){
            // 将队列头节点取出
            let node = queueNode.shift()
            // 取出后放入层节点，即要加入到结果的节点
            levelList.push(node.val)
            // 判断头节点是否还有左右节点
            node.left && queueNode.push(node.left)
            node.right && queueNode.push(node.right)
        }
        res.push(levelList)
    }
    return res
};
```
**107.二叉树的层次遍历II**
```js
var levelOrderBottom = function(root) {
    // 两种思路：一种是按自上向下遍历，最后反转；另一种是在自上向下遍历的时候，把每层加入到数组头部
    const res = []
    if(!root) return res
    const queneNode = [root]
    while(queneNode.length){
        const levelNode = []
        const len = queneNode.length
        for(let i=0; i<len; i++){
            let node = queneNode.shift()
            levelNode.push(node.val)
            node.left && queneNode.push(node.left)
            node. right && queneNode.push(node.right)
        }
        // 这里可以把每一层的节点加入到结果数组的头部
        // res.unshift(levelNode)
        // 或者
        res.push(levelNode)
    }
    // return res
    // 把结果数组反转
    return res.reverse()
};
```
**199.二叉树的右视图**
```js
var rightSideView = function(root) {
    // 正常层序遍历，只将每一层的最后一个节点加入到结果数组
    const res = []
    if(!root) return res
    const queneNode = [root]
    while(queneNode.length){
        const len = queneNode.length
        for(let i=1; i<=len; i++){
            const node = queneNode.shift()
            i === len && res.push(node.val)
            node.left && queneNode.push(node.left)
            node.right && queneNode.push(node.right)
        }
    }
    return res
};
```
**637.二叉树的层平均值**
```js
var averageOfLevels = function(root) {
    // 在层序遍历的基础上，对每一层进行平均值计算，然后加入到结果数组
    const res = []
    const qunenNode = [root]
    while(qunenNode.length){
        const levelNode = []
        const len = qunenNode.length
        for(let i=1; i<=len; i++){
            let node = qunenNode.shift()
            levelNode.push(node.val)
            node.left && qunenNode.push(node.left)
            node.right && qunenNode.push(node.right)
        }
        let sum = levelNode.reduce((preVal, curVal) => preVal + curVal)
        res.push((sum/len).toFixed(5))
    }
    return res
};
```
**429.N叉树的前序遍历**
```js
var levelOrder = function(root) {
    const res = []
    if(!root) return res
    const queueNode = [root]
    while(queueNode.length){
        const levelNode = []
        const len = queueNode.length
        for(let i=1; i<=len; i++){
            let node = queueNode.shift()
            levelNode.push(node.val)
            for(let child of node.children){
                child && queueNode.push(child)
            }
        }
        res.push(levelNode)
    }
    return res
};
```
**515.在每个树行中找最大值**
```js
var largestValues = function(root) {
    // 层序遍历，找到最大值存入结果(每一层都加入到层队列中保存，然后对该层进行判断)
    const res = []
    if(!root) return res
    const queueNode = [root]
    while(queueNode.length) {
        const len = queueNode.length
        const levelNode = []
        for(let i=0; i<len; i++){
            let node = queueNode.shift()
            levelNode.push(node.val)
            node.left && queueNode.push(node.left)
            node.right && queueNode.push(node.right)
        }
        let maxVal = Math.max(...levelNode)
        res.push(maxVal)
    }
    return res
};
```
**116.填充每个节点的下一个右侧节点指针**
思路：
🦈判断每一层的头节点
有无左节点：有则指向右节点node.left.next = node.right
有无下一个节点：有则让头节点的右节点指向下一节点的左节点node.right.nxext = node.next.left
```js
var connect = function(root) {
    // 判断每一层有没有右侧节点
    // 即遍历到每一层最后一个值next赋值为#---错误
    // 题意是提供指针每层都连起
    if(!root) return root
    const queueNode = [root]
    while(queueNode.length){
        // 将每层头节点取出
        let node = queueNode.shift()
        if(node.left){
            node.left.next = node.right
            if(node.next) node.right.next = node.next.left
            queueNode.push(node.left)
            queueNode.push(node.right)
        }
    }
    return root
};
```

方法二：双队列
```js
var connect = function(root) {
    // 双队列，对每一层进行单独处理
    if(!root) return root
    const queueNode = [root]
    while(queueNode.length){
        const levelNode = []
        let length = queueNode.length
        for(let i=0; i<length; i++){
            let node = queueNode.shift()
            levelNode.push(node)
            // 对每一层节点做出判断，不是一个节点就要加上指针
            if(levelNode.length > 1){
                levelNode[levelNode.length-2].next = node
            }
            node.left && queueNode.push(node.left)
            node.right && queueNode.push(node.right)
        }
    }
    return root
};
```
**117.填充每个节点的下一个右侧节点指针II**
⭐官方题解都错
```js
// var connect = function(root) {
//     // 层序遍历
//     if(!root) return root
//     const queueNode = [root]
//     while(queueNode.length){
//         const len = queueNode.length
//         let last = null
//         for(let i=1; i<=len; i++){
//             let node = queueNode.shift()
//             node.left && queueNode.push(node.left)
//             node.right && queueNode.push(node.right)
//             if(i !== 1) last.next = node
//             last = node
//         }
//     }
//     return root
// };

var connect = function(root) {
    if (root === null) {
        return null;
    }
    const queue = [root];
    while (queue.length) {
        const n = queue.length;
        let last = null;
        for (let i = 1; i <= n; ++i) {
            let f = queue.shift();
            if (f.left !== null) {
                queue.push(f.left);
            }
            if (f.right !== null) {
                queue.push(f.right);
            }
            if (i !== 1) {
                last.next = f;
            }
            last = f;
        }
    }
    return root;
};
```
**104.二叉树的最大深度**
**111.二叉树的最小深度**
****
****
****
****