# 二叉树
## 知识点
## 题目
递归法
实现递归的三个步骤：
1. 确定参数和返回值
2. 确定终止条件
3. 确定单层递归逻辑
**144.二叉树的前序遍历**
```js
var preorderTraversal = function(root) {
    // 递归前序遍历
    const ans = []
    preTraversal(root, ans)
    return ans
};
// 定义前序遍历
const preTraversal = (cur, res) => {
    if(cur === null) return;
    res.push(cur.val)
    preTraversal(cur.left, res)
    preTraversal(cur.right, res)    
}
```
**145.二叉树的后序遍历**
```js
var postorderTraversal = function(root) {
    const ans = []
    postTraversal(root, ans)
    return ans
};
const postTraversal = (cur, res) => {
    if(cur === null) return
    postTraversal(cur.left, res)
    postTraversal(cur.right, res)
    res.push(cur.val)
    return res
}
```
**94.二叉树的中序遍历**
```js
var inorderTraversal = function(root) {
    const ans = []
    inTraversal(root, ans)
    return ans
};
const inTraversal = (cur, res) => {
    if(cur === null) return
    inTraversal(cur.left, res)
    res.push(cur.val)
    inTraversal(cur.right, res)
    return res
}
```

迭代法
**144.二叉树的前序遍历**
```js
var preorderTraversal = function(root) {
    // 迭代法:前序遍历，压栈顺寻  中右左
    const res = []
    if(!root) return res
    const stack = []
    stack.push(root)
    while(stack.length){
        let cur = stack.pop()
        res.push(cur.val)
        cur.right && stack.push(cur.right)
        cur.left && stack.push(cur.left)
    }
    return res
};
```
**94.二叉树的中序遍历**
```js
var inorderTraversal = function(root) {
    // 迭代法：中序遍历  左中右
    const res = []
    if(!root) return res
    const stack = []
    let cur = root
    while(cur || stack.length){
        if(cur){
            stack.push(cur)
            cur = cur.left
        }else{
            cur = stack.pop()
            res.push(cur.val)
            cur = cur.right
        }
    }
    return res
};
```
**145.二叉树的后序遍历**
```js
var postorderTraversal = function(root) {
    // 迭代法：后序遍历 左右中
    // 思路：在前序遍历的基础上去做，要么采用前序遍历然后反转数组，要么直接加入到结果数组头部
    const res = []
    if(!root) return res
    const stack = [root]
    while(stack.length){
        // 前序
        let cur = stack.pop()
        res.unshift(cur.val)
        cur.left && stack.push(cur.left)
        cur.right && stack.push(cur.right)
    }
    return res
};
```

**102.二叉树的层序遍历**
```js
var levelOrder = function(root) {
    // 双重队列
    const res = []
    if(!root){
        return res
    }
    // 模拟队列---取值时用shift()就可以
    const queueNode = []
    queueNode.push(root)
    while(queueNode.length){
        // 队列---保存一层节点
        const levelList = []
        // 这里一定要使用固定大小length，因为queueNode.length是不断变化的
        const length = queueNode.length
        for(let i=1; i<=length; i++){
            // 将队列头节点取出
            let node = queueNode.shift()
            // 取出后放入层节点，即要加入到结果的节点
            levelList.push(node.val)
            // 判断头节点是否还有左右节点
            node.left && queueNode.push(node.left)
            node.right && queueNode.push(node.right)
        }
        res.push(levelList)
    }
    return res
};
```
**107.二叉树的层次遍历II**
```js
var levelOrderBottom = function(root) {
    // 两种思路：一种是按自上向下遍历，最后反转；另一种是在自上向下遍历的时候，把每层加入到数组头部
    const res = []
    if(!root) return res
    const queneNode = [root]
    while(queneNode.length){
        const levelNode = []
        const len = queneNode.length
        for(let i=0; i<len; i++){
            let node = queneNode.shift()
            levelNode.push(node.val)
            node.left && queneNode.push(node.left)
            node. right && queneNode.push(node.right)
        }
        // 这里可以把每一层的节点加入到结果数组的头部
        // res.unshift(levelNode)
        // 或者
        res.push(levelNode)
    }
    // return res
    // 把结果数组反转
    return res.reverse()
};
```
**199.二叉树的右视图**
```js
var rightSideView = function(root) {
    // 正常层序遍历，只将每一层的最后一个节点加入到结果数组
    const res = []
    if(!root) return res
    const queneNode = [root]
    while(queneNode.length){
        const len = queneNode.length
        for(let i=1; i<=len; i++){
            const node = queneNode.shift()
            i === len && res.push(node.val)
            node.left && queneNode.push(node.left)
            node.right && queneNode.push(node.right)
        }
    }
    return res
};
```
**637.二叉树的层平均值**
```js
var averageOfLevels = function(root) {
    // 在层序遍历的基础上，对每一层进行平均值计算，然后加入到结果数组
    const res = []
    const qunenNode = [root]
    while(qunenNode.length){
        const levelNode = []
        const len = qunenNode.length
        for(let i=1; i<=len; i++){
            let node = qunenNode.shift()
            levelNode.push(node.val)
            node.left && qunenNode.push(node.left)
            node.right && qunenNode.push(node.right)
        }
        let sum = levelNode.reduce((preVal, curVal) => preVal + curVal)
        res.push((sum/len).toFixed(5))
    }
    return res
};
```
**429.N叉树的前序遍历**
```js
var levelOrder = function(root) {
    const res = []
    if(!root) return res
    const queueNode = [root]
    while(queueNode.length){
        const levelNode = []
        const len = queueNode.length
        for(let i=1; i<=len; i++){
            let node = queueNode.shift()
            levelNode.push(node.val)
            for(let child of node.children){
                child && queueNode.push(child)
            }
        }
        res.push(levelNode)
    }
    return res
};
```
**515.在每个树行中找最大值**
**116.填充每个节点的下一个右侧节点指针**
**117.填充每个节点的下一个右侧节点指针II**
**104.二叉树的最大深度**
**111.二叉树的最小深度**
****
****
****
****