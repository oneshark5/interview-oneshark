# 单调栈
使用单调栈的场景：一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置

### 
**739. 每日温度**
```js
var dailyTemperatures = function(temperatures) {
    // 单调栈
    /**
    思路：从栈顶到栈底元素递增排序---入栈的是元素的下标
    1.遍历元素小于栈顶元素，直接入栈
    2.遍历元素等于栈顶元素，入栈
    3.遍历元素大于栈顶元素，计算结果，并弹栈
     */
    const len = temperatures.length
    const res = new Array(len).fill(0)
    const stack = [0]
    for(let i=1; i<len; i++){
        // 判断情况，是否入栈
        if(temperatures[i] < temperatures[stack.at(-1)]){
            stack.push(i)
        }
        else if (temperatures[i] === temperatures[stack.at(-1)]){
            stack.push(i)
        }else{
            while(stack && temperatures[i] > temperatures[stack.at(-1)]){
                res[stack.at(-1)] = i - stack.at(-1)
                stack.pop()
            }
            stack.push(i)
        } 
    }
    return res
};
```
### 496. 下一个更大元素
**暴力解法**
```js
var nextGreaterElement = function(nums1, nums2) {
    // 题意：由num1找到num2对应元素的位置，然后判断在num2中，该位置后面有没有比该值更大的元素
    // 暴力解法：双层for循环
    const res = []
    // 映射
    let map = {}
    for(let i=0; i<nums2.length; i++){
        map[nums2[i]] = i
    }
    for(let i=0; i<nums1.length; i++){
        for(let j=map[nums1[i]]; j<nums2.length; j++){
            if(nums2[j] > nums1[i]) {
                res.push(nums2[j])
                break
            }else if(nums2[j]<=nums1[i] && j===nums2.length-1){
                res.push(-1)
            }
        }
    }
    return res
};
```
**单调栈**
