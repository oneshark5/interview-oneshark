# 单调栈
使用单调栈的场景：一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置

### 
**739. 每日温度**
```js
var dailyTemperatures = function(temperatures) {
    // 单调栈
    /**
    思路：从栈顶到栈底元素递增排序---入栈的是元素的下标
    1.遍历元素小于栈顶元素，直接入栈
    2.遍历元素等于栈顶元素，入栈
    3.遍历元素大于栈顶元素，计算结果，并弹栈
     */
    const len = temperatures.length
    const res = new Array(len).fill(0)
    const stack = [0]
    for(let i=1; i<len; i++){
        // 判断情况，是否入栈
        if(temperatures[i] < temperatures[stack.at(-1)]){
            stack.push(i)
        }
        else if (temperatures[i] === temperatures[stack.at(-1)]){
            stack.push(i)
        }else{
            while(stack && temperatures[i] > temperatures[stack.at(-1)]){
                res[stack.at(-1)] = i - stack.at(-1)
                stack.pop()
            }
            stack.push(i)
        } 
    }
    return res
};
```
### 496. 下一个更大元素
**暴力解法**
```js
var nextGreaterElement = function(nums1, nums2) {
    // 题意：由num1找到num2对应元素的位置，然后判断在num2中，该位置后面有没有比该值更大的元素
    // 暴力解法：双层for循环
    const res = []
    // 映射
    let map = {}
    for(let i=0; i<nums2.length; i++){
        map[nums2[i]] = i
    }
    for(let i=0; i<nums1.length; i++){
        for(let j=map[nums1[i]]; j<nums2.length; j++){
            if(nums2[j] > nums1[i]) {
                res.push(nums2[j])
                break
            }else if(nums2[j]<=nums1[i] && j===nums2.length-1){
                res.push(-1)
            }
        }
    }
    return res
};
```
**单调栈**
逻辑：先遍历num2即待比较的数组，然后记录符合下一个更大元素的键值到哈希表；最后直接遍历num1去哈希表中找结果即可。
思路：
1. 遍历num2记录符合下一最大元素的条件到哈希表
2. 遍历剩余栈，值为-1
3. 遍历num1，直接到哈希表找查找结果
```js
var nextGreaterElement = function(nums1, nums2) {
    // 单调栈
    let stack = [], map = new Map(), ans = [];
    nums2.forEach(item => {
        while(stack && item > stack.at(-1)){
            map.set(stack.pop(), item)
        }
        stack.push(item)
    })
    // 遍历栈
    stack.forEach(item => map.set(item, -1))
    // 遍历num1
    nums1.forEach(item => ans.push(map.get(item)))
    return ans
};
```

**503. 下一个更大元素 II**
方法一：采用拼接两个数组的形式
```js
var nextGreaterElements = function(nums) {
    // 单调栈---栈中存放的是下标
    // 方法一：采用拼接两个数组的形式
    const newnums = [...nums, ...nums]
    const stack = [0]
    const res = new Array(newnums.length).fill(-1)
    for(let i=0; i<newnums.length; i++){
        while(newnums[i] > newnums[stack.at(-1)]){
            res[stack.at(-1)] =  newnums[i]
            stack.pop()
        }
        stack.push(i)
    }
    return res.slice(0, newnums.length/2)
};
```

方法二：遍历两遍数组
```js
var nextGreaterElements = function(nums) {
    // 单调栈---栈中存放的是下标
    // 方法二：遍历两遍数组
    // 要清楚理解三种情况的处理方法
    const stack = []
    const ans = new Array(nums.length).fill(-1)
    for(let i=0; i<nums.length*2; i++){
        // 当大于栈顶元素时，则找到结果，并做弹栈处理，之后再压栈
        while(stack && nums[i%nums.length] > nums[stack.at(-1)]){
            // 当大于栈顶元素时，就是找到了值，赋值时肯定是把遍历得到的值赋值给下标为栈顶结果集中
            ans[stack.at(-1)] = nums[i%nums.length]//⭐
            stack.pop()
        }
        stack.push(i%nums.length)
    }
    return ans
};
```
